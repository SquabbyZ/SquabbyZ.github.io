<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Nginx]]></title>
    <url>%2FNginx%2F</url>
    <content type="text"><![CDATA[如何离线安装 Nginx准备工作gcc 和 g++ 在 Linux 系统中必须有可以使用下面的命令来测试是否有 gcc 和 g++ 1yum install -y gcc gcc-c++ 也可以使用下面的命令 1gcc 提示你编译失败,就证明已经安装。 准备 Nginx 的安装包和 pcre zlib openssl 三个安装包我这里用的是 Nginx-1.3.1 pcre-8.31 zlib-1.2.3 openssl-1.0.1.c 安装 Nginx 依赖包1cd home/ 切换到 home 目录下 1mkdir Jack 创建一个名字为 Jack 的文件(特意说明下，Jack 就是你的非 root 的登录名),并且创建一个名为 nginx-server 的文件夹用来存放 nginx 12cd Jack/mkdir nginx-server 进入到 Jack 文件夹内，然后把安装包跟依赖包到考入到该目录下 之后我们逐步安装： 安装 pcre 1234567891011121314151617181920tar -zxvf pcre-8.31.tar.gzcd pcre-8.31./configuresu你的 root 登录密码makemake installsu Jack你的 Jack 用户登录密码cd ../ 安装 openssl 1234567891011121314151617181920tar -zxvf openssl-1.0.1.c.tar.gzcd openssl-1.0.1.c./configsu你的 root 登录密码makemake installsu Jack你的 Jack 用户登录密码cd ../ 安装 zlib 1234567891011121314151617181920tar -zxvf zlib-1.2.3.tar.gzcd zlib-1.2.3CFLAGS="-O3 -fPIC" ./configuresu你的 root 登录密码makemake installsu Jack你的 Jack 用户登录密码cd ../ 安装 nginx 1234567891011121314151617181920212223tar -zxvf nginx.1.3.1.tar.gzcd nginx-1.3.1./configure --prefix=/home/Jack/nginx-server --with-pcre=/home/Jack/pcre-8.31 --with-openssl-1.0.1.c=/home/Jack/openssl-1.0.1.c --with-zlib=/home/Jack/zlib-1.2.3su你的 root 登录密码makemake installsu Jack你的 Jack 用户登录密码cd ../cd nginx-serverls ls 之后你可以看到 conf html sbin 等 4 个文件 然后 12cd sbin/sudo ./nginx -v 显示出 nginx-1.3.1 ,就证明安装成功 Nginx 安装成功后，起项目报错问题以及解决办法 Nginx 启动报错: nginx :[alert] could not open error log file…..解决办法: 在非 root 登录下 使用 “sudo ./nginx”，之后输入 Jack 的登录密码即可]]></content>
  </entry>
  <entry>
    <title><![CDATA[nodejsonCentos]]></title>
    <url>%2FnodejsonCentos%2F</url>
    <content type="text"><![CDATA[在 Centos 7.5 的腾讯云服务器上安装全局 Node.js首先使用 1cd ~ 将当期目录切换到 ~ 目录下 12wget https://nodejs.org/dist/v10.16.0/node-v10.16.0-linux-x64.tar.xz 这个是在 node 官网上下载 node 包,将命令中的版本号换成对应的版本号就可以,我下载的版本是 V.10.16.0 然后在当前下载的 jar 包的文件夹下，使用如下命令，将 jar 包解压 1tar -xvf node-v10.16.0-linux-x64.tar.xz 先确认你 nodejs 的路径，我这里的路径为~/node-v9.3.0-linux-x64/bin。确认后依次执行 12ln -s ~/node-v9.3.0-linux-x64/bin/node /usr/bin/nodeln -s ~/node-v9.3.0-linux-x64/bin/npm /usr/bin/npm 注意 ln 指令用于创建关联（类似与 Windows 的快捷方式）必须给全路径，否则可能关联错误。 最后使用命令 12node -vnpm -v 显示出对应的版本号，就证明安装成功了]]></content>
  </entry>
  <entry>
    <title><![CDATA[elasticsearch]]></title>
    <url>%2Felasticsearch%2F</url>
    <content type="text"><![CDATA[elasticsearch 数据库要加入权限控制，使用的是 x-pack 插件，前端直接访问数据库的时候，只需要在 ajax 请求的加入 12345678910$.ajax(&#123; url: "ES数据库地址", type: "POST/GET", data: "传入的数据", contentType: "application/json", beforeSend: function(xhr) &#123; xhr.setRequestHeader("Authorization", `Basic $&#123;btoa("username:password")&#125;`); &#125;, success: function(result) &#123;&#125;&#125;); 会涉及到跨域的问题，要将 es 配置文件中涉及到跨域的地方打开，包括带请求头的部分 es 数据库修改密码这里测试的账户为: elastic 1234curl -u elastic -XPUT 'http://192.168.1.11:9200/_xpack/security/user/elastic/_password?pretty' -H 'Content-Type: application/json' -d'&#123; "password" : "new_password"&#125;' 其中 192.168.1.11为 es 数据库的地址 IP 参考地址： https://www.jianshu.com/p/2ecac3ae1b67]]></content>
  </entry>
  <entry>
    <title><![CDATA[regexpAll]]></title>
    <url>%2FregexpAll%2F</url>
    <content type="text"><![CDATA[前端常用的正则表达式大全1. 匹配用户名规则描述: · 长度 4-6 位： {4,16}· 字母： [a-z][a-z]· 数字： [0-9]· 下划线： [_]· 减号： [-]]]></content>
  </entry>
  <entry>
    <title><![CDATA[同心圆坐标算法]]></title>
    <url>%2FechartsGraph%2F</url>
    <content type="text"><![CDATA[前言由于项目中要搭建人物关系图谱，基于定制化不是很强，并且要求在短时间内实现同心圆人物关系图的效果，因此，我采用的是基于 Echarts V4 版本和 JQuery V3.4.0 来先实现的 graph 图,根据自己的摸索，研究出来了，echarts 的 graph 图坐标系的分布： 先来阐述下，Echarts 的 graph 图的坐标系的展示假设我们取的展示 echarts 的盒子的大小为 400pxX400pxecharts 中 graph 的坐标系是左上角为 (0,0)点，右下角为 (400,400)根据这个坐标位置的关系，我们可以确定要做同心圆的中心点的位置为 (200,200),话不多说，先来个干货,呈上一段动态生成的 nodes 和 links 的基本 demo 数据 nodes 的数据的 id 一定要是字符串的类型，不要是数字 否则会出现如图的效果点点击这里 12345678910111213141516171819202122var nodes = []; var links = []; for (var i = 0; i &lt; 6; i++) &#123; nodes.push(&#123; id: `$&#123;i&#125;`, //这个 ID 在 nodes 数据中必须唯一，在 links 中可以重复出现 name: `demo$&#123;i&#125;`, //每个节点显示的名字 symbolSize: 20, //节点在图中显示的大小 value: 20 //每个节点的数据大小，一般情况下保持和每个节点的 symbolSize 的值一致 &#125;); &#125; nodes.forEach((ele, index, arr) =&gt; &#123; if (index != arr.length - 1) &#123; links.push(&#123; id: `$&#123;index * 2&#125;`, //这个 ID 在 links 必须唯一，但是只是作为每条数据的 ID 而已，不影响图展示 name: `demo$&#123;index&#125;---demo$&#123;index * 1 + 1 * 1&#125;`, //节点和节点的连接线上显示的数据内容 source: `$&#123;index&#125;`, //起始点(来源) target: `$&#123;index * 1 + 1 * 1&#125;` &#125;); &#125; &#125;); 上面的代码是最基本的数据，但是要注意一点，如果你在 option 中 的 series 数组下的 layout 的属性值不写，或者其值为 none 的时候，会报错 Uncaught TypeError: Cannot read property ‘off’ of undefined echarts 中 option 的 series 的 layout 的默认属性值默认为 none这个问题的主要原因,就是在于 nodes 数据上,对于初次使用 echarts 的 graph 图的同学来说，上来就给 nodes 数据加入 x , y 坐标的值，难度系数比较大，因为不懂如何通过自己算出每个点的坐标来进行展示，所以就会报上面的问题，还有可能是你的 nodes 数据中的 某个点的 x 或者 y 出现 NAN 的情况,所以想熟悉下的童鞋，在没有给 nodes 数据传入 x , y 的时候，一定要设置为 “force” 或者 “circular”. 上个完整的前端代码，以供同学们学习：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8" /&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge" /&gt; &lt;title&gt;echarts 同心圆图&lt;/title&gt; &lt;/head&gt; &lt;script src="./echarts.js"&gt;&lt;/script&gt; &lt;script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"&gt;&lt;/script&gt; &lt;style&gt; body &#123; box-sizing: border-box; margin: 0; width: 100%; height: 100%; &#125; &lt;/style&gt; &lt;body&gt; &lt;div id="graph" style="width:vw;height:100vh;"&gt;&lt;/div&gt; &lt;script&gt; $(function() &#123; var nodes = []; var links = []; for (var i = 0; i &lt; 6; i++) &#123; nodes.push(&#123; id: `$&#123;i&#125;`, //这个 ID 在 nodes 数据中必须唯一，在 links 中可以重复出现 name: `demo$&#123;i&#125;`, //每个节点显示的名字 symbolSize: 20, //节点在图中显示的大小 value: 20 //每个节点的数据大小，一般情况下保持和每个节点的 symbolSize 的值一致 &#125;); &#125; nodes.forEach((ele, index, arr) =&gt; &#123; if (index != arr.length - 1) &#123; links.push(&#123; id: index * 2 + 3, //这个 ID 在 links 必须唯一，但是只是作为每条数据的 ID 而已，不影响图展示 name: `demo$&#123;index&#125;---demo$&#123;index * 1 + 1 * 1&#125;`, //节点和节点的连接线上显示的数据内容 source: `$&#123;index&#125;`, //起始点(来源) target: `$&#123;index * 1 + 1 * 1&#125;` &#125;); &#125; &#125;); getGraph(nodes, links); &#125;); function getGraph(nodes, links) &#123; var graph = &#123; nodes: nodes, links: links &#125;; myChart = echarts.init(document.getElementById("graph")); option = &#123; title: &#123; //标题 text: "同心圆关系图", //标题展示的内容 top: "10", //标题定位，距顶部的距离为10 left: "center" //距左边的值为 "center" (中间) &#125;, tooltip: &#123; //修改划上去的edge显示内容 formatter: function(param) &#123; if (param.dataType == "edge") &#123; return `$&#123;param.data.source&#125;&gt;$&#123;param.data.target&#125;`; &#125; return; &#125;, rich: &#123; color: "black" &#125; &#125;, animationDuration: 1500, //初始动画的时长，支持回调函数，可以通过每个数据返回不同的 delay 时间实现更戏剧的初始动画效果 animationEasingUpdate: "quinticInOut", //数据更新动画的缓动效果 series: [ &#123; type: "graph", //展示的类型为关系图 // layout: "force", layout: "circular", //图的布局。'none' 不采用任何布局，使用节点中提供的 x， y 作为节点的位置。'circular' 采用环形布局，'force' 采用力引导布局,[ default: 'none' ] roam: true, //是否开启鼠标缩放和平移漫游。默认不开启。如果只想要开启缩放或者平移，可以设置成 'scale' 或者 'move'。设置成 true 为都开启,[ default: false ] draggable: true, //节点是否可拖拽，只在使用力引导布局的时候有用,[ default: false ] focusNodeAdjacency: true, //是否在鼠标移到节点上的时候突出显示节点以及节点的边和邻接节点,[ default: false ] data: graph.nodes, //节点数据 links: graph.links, //连线数据 symbol: "circle", //关系图节点标记的图形。ECharts 提供的标记类型包括 'circle', 'rect', 'roundRect', 'triangle', 'diamond', 'pin', 'arrow', 'none',可以通过 'image://url' 设置为图片，其中 URL 为图片的链接，或者 dataURI,[ default: 'circle' ] edgeSymbol: ["circle", "arrow"], //边两端的标记类型，可以是一个数组分别指定两端，也可以是单个统一指定。默认不显示标记，常见的可以设置为箭头,[ default: ['none', 'none'] ] edgeSymbolSize: 10, //边两端的标记大小，可以是一个数组分别指定两端，也可以是单个统一指定。可以是数组[10,10],[ default: 10 ] cursor: "pointer", //鼠标悬浮时在图形元素上时鼠标的样式是什么。同 CSS 的 cursor,[ default: 'pointer' ] itemStyle: &#123; //图形样式 normal: &#123; color: "#06d55e", borderColor: "#fff", borderWidth: 1, shadowBlur: 10, shadowColor: "rgba(0,0,0,0.3)" &#125; &#125;, label: &#123; //图形上的文本标签，可用于说明图形的一些数据信息，比如值，名称等，label选项在 ECharts 2.x 中放置于itemStyle下，在 ECharts 3 中为了让整个配置项结构更扁平合理，label 被拿出来跟 itemStyle 平级，并且跟 itemStyle 一样拥有 emphasis 状态。 show: true, position: "inside", formatter: "&#123;b&#125;", fontSize: 20, rich: &#123; b: &#123; color: "#fff" &#125; &#125; &#125;, lineStyle: &#123; //关系边的公用线条样式。其中 lineStyle.color 支持设置为'source'或者'target'特殊值，此时边会自动取源节点或目标节点的颜色作为自己的颜色。 color: "source", curveness: 0.1 //边的曲度，支持从 0 到 1 的值，值越大曲度越大 &#125;, edgeLabel: &#123; //连线上显示的内容的设置 color: "black", position: "middle" //连线上的内容显示的位置 &#125;, emphasis: &#123; //hover展示的效果 lineStyle: &#123; width: 3 &#125;, label: &#123; show: false &#125; &#125; &#125; ] &#125;; myChart.setOption(option); window.onresize = function() &#123; //随着浏览器视窗的变化，自适应 myChart.resize(); &#125;; &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 展示的图片效果 加入同心圆算法上干货: 基础算法12345678910111213141516171819//同心圆关系图坐标点计算方法function getPoint(r, ox, oy, count) &#123; var point = []; //结果 /* * 求圆周上等分点的坐标 * ox,oy为圆心坐标 * r为半径 * count为等分个数 */ var radians = (Math.PI / 180) * Math.round(360 / count), //弧度 i = 0; for (; i &lt; count; i++) &#123; var x = ox + r * Math.sin(radians * i), y = oy + r * Math.cos(radians * i); point.unshift(&#123; x: x, y: y &#125;); //为保持数据顺时针 &#125; return point;&#125; 这个是基本的同心圆坐标的数学算法，下面我们把上面的代码进行改造下 处理后算法12345678910111213141516171819202122232425262728function getPoint(centerId, nodes) &#123; /* * 求圆周上等分点的坐标 * ox,oy为圆心坐标 * r为半径 */ var ox = window.innerWidth / 2; var oy = window.innerHeight / 2; var r = ox &gt; oy ? oy - 100 : ox - 100; var newNodes = []; var radians = (Math.PI / 180) * Math.round(360 / (nodes.length - 1)), //弧度 i = 0; for (; i &lt; nodes.length; i++) &#123; if (nodes[i].id == centerId) &#123; newNodes.unshift(nodes[i]); &#125; else &#123; newNodes.push(nodes[i]); &#125; &#125; for (var j = 0; j &lt; newNodes.length; j++) &#123; newNodes[j].x = ox + r * Math.sin(radians * j); newNodes[j].y = oy + r * Math.cos(radians * j); &#125; //中心点位更新 newNodes[0].x = ox; newNodes[0].y = oy; return newNodes || null; &#125; 直接上最终代码:记得把 layout 的值修改为 “none” 或者直接注释/删除掉 layout 属性 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8" /&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge" /&gt; &lt;title&gt;echarts 同心圆图&lt;/title&gt; &lt;/head&gt; &lt;script src="./echarts.js"&gt;&lt;/script&gt; &lt;script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"&gt;&lt;/script&gt; &lt;style&gt; body &#123; box-sizing: border-box; margin: 0; width: 100%; height: 100%; &#125; &lt;/style&gt; &lt;body&gt; &lt;div id="graph" style="width:vw;height:100vh;"&gt;&lt;/div&gt; &lt;script&gt; $(function() &#123; var nodes = []; var links = []; for (var i = 0; i &lt; 6; i++) &#123; nodes.push(&#123; id: `$&#123;i&#125;`, //这个 ID 在 nodes 数据中必须唯一，在 links 中可以重复出现 name: `demo$&#123;i&#125;`, //每个节点显示的名字 symbolSize: 20, //节点在图中显示的大小 value: 20 //每个节点的数据大小，一般情况下保持和每个节点的 symbolSize 的值一致 // x: 662.0767566415067*i, // y: 71.20162612375115 &#125;); &#125; nodes.forEach((ele, index, arr) =&gt; &#123; if (index != arr.length - 1) &#123; links.push(&#123; id: index * 2 + 3, //这个 ID 在 links 必须唯一，但是只是作为每条数据的 ID 而已，不影响图展示 name: `demo$&#123;index&#125;---demo$&#123;index * 1 + 1 * 1&#125;`, //节点和节点的连接线上显示的数据内容 source: `$&#123;index&#125;`, //起始点(来源) target: `$&#123;index * 1 + 1 * 1&#125;` &#125;); &#125; &#125;); nodes = getPoint("1", nodes); if (nodes) &#123; getGraph(nodes, links); &#125; &#125;); function getGraph(nodes, links) &#123; var graph = &#123; nodes: nodes, links: links &#125;; myChart = echarts.init(document.getElementById("graph")); option = &#123; title: &#123; //标题 text: "同心圆关系图", //标题展示的内容 top: "10", //标题定位，距顶部的距离为10 left: "center" //距左边的值为 "center" (中间) &#125;, tooltip: &#123; //修改划上去的edge显示内容 formatter: function(param) &#123; if (param.dataType == "edge") &#123; return `$&#123;param.data.source&#125;&gt;$&#123;param.data.target&#125;`; &#125; return; &#125;, rich: &#123; color: "black" &#125; &#125;, animationDuration: 1500, //初始动画的时长，支持回调函数，可以通过每个数据返回不同的 delay 时间实现更戏剧的初始动画效果 animationEasingUpdate: "quinticInOut", //数据更新动画的缓动效果 series: [ &#123; type: "graph", //展示的类型为关系图 // layout: "force", layout: "none", //图的布局。'none' 不采用任何布局，使用节点中提供的 x， y 作为节点的位置。'circular' 采用环形布局，'force' 采用力引导布局,[ default: 'none' ] roam: true, //是否开启鼠标缩放和平移漫游。默认不开启。如果只想要开启缩放或者平移，可以设置成 'scale' 或者 'move'。设置成 true 为都开启,[ default: false ] draggable: true, //节点是否可拖拽，只在使用力引导布局的时候有用,[ default: false ] focusNodeAdjacency: true, //是否在鼠标移到节点上的时候突出显示节点以及节点的边和邻接节点,[ default: false ] data: graph.nodes, //节点数据 links: graph.links, //连线数据 symbol: "circle", //关系图节点标记的图形。ECharts 提供的标记类型包括 'circle', 'rect', 'roundRect', 'triangle', 'diamond', 'pin', 'arrow', 'none',可以通过 'image://url' 设置为图片，其中 URL 为图片的链接，或者 dataURI,[ default: 'circle' ] edgeSymbol: ["circle", "arrow"], //边两端的标记类型，可以是一个数组分别指定两端，也可以是单个统一指定。默认不显示标记，常见的可以设置为箭头,[ default: ['none', 'none'] ] edgeSymbolSize: 10, //边两端的标记大小，可以是一个数组分别指定两端，也可以是单个统一指定。可以是数组[10,10],[ default: 10 ] cursor: "pointer", //鼠标悬浮时在图形元素上时鼠标的样式是什么。同 CSS 的 cursor,[ default: 'pointer' ] itemStyle: &#123; //图形样式 normal: &#123; color: "#06d55e", borderColor: "#fff", borderWidth: 1, shadowBlur: 10, shadowColor: "rgba(0,0,0,0.3)" &#125; &#125;, label: &#123; //图形上的文本标签，可用于说明图形的一些数据信息，比如值，名称等，label选项在 ECharts 2.x 中放置于itemStyle下，在 ECharts 3 中为了让整个配置项结构更扁平合理，label 被拿出来跟 itemStyle 平级，并且跟 itemStyle 一样拥有 emphasis 状态。 show: true, position: "inside", formatter: "&#123;b&#125;", fontSize: 20, rich: &#123; b: &#123; color: "#fff" &#125; &#125; &#125;, lineStyle: &#123; //关系边的公用线条样式。其中 lineStyle.color 支持设置为'source'或者'target'特殊值，此时边会自动取源节点或目标节点的颜色作为自己的颜色。 color: "source", curveness: 0.1 //边的曲度，支持从 0 到 1 的值，值越大曲度越大 &#125;, edgeLabel: &#123; //连线上显示的内容的设置 color: "black", position: "middle" //连线上的内容显示的位置 &#125;, emphasis: &#123; //hover展示的效果 lineStyle: &#123; width: 3 &#125;, label: &#123; show: false &#125; &#125; &#125; ] &#125;; myChart.setOption(option); window.onresize = function() &#123; //随着浏览器视窗的变化，自适应 myChart.resize(); &#125;; &#125; function getPoint(centerId, nodes) &#123; /* * 求圆周上等分点的坐标 * ox,oy为圆心坐标 * r为半径 *centerId为想要作为中心点的节点的ID *nodes为要传入到echarts中的节点数据 */ var ox = window.innerWidth / 2; var oy = window.innerHeight / 2; var r = ox &gt; oy ? oy - 100 : ox - 100; //整个同心圆的大小半径 var newNodes = []; //计算完的结果 var radians = (Math.PI / 180) * Math.round(360 / (nodes.length - 1)), //弧度 i = 0; for (; i &lt; nodes.length; i++) &#123; //这个for循环是让要放在中心点的那个点，放在数组的第一位，为后面的将中心点的坐标赋值给它提供便利 if (nodes[i].id == centerId) &#123; newNodes.unshift(nodes[i]); //中心点坐标放到第一位的方法 &#125; else &#123; newNodes.push(nodes[i]); //正常的 push &#125; &#125; for (var j = 1; j &lt; newNodes.length; j++) &#123; //这里是将数据除了索引为0的数组元素添加计算好的 x y 坐标 newNodes[j].x = ox + r * Math.sin(radians * j); newNodes[j].y = oy + r * Math.cos(radians * j); &#125; //中心节点的坐标 newNodes[0].x = ox; newNodes[0].y = oy; return newNodes || null; &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 最后的效果图为: 造数据的时候，nodes 的 id 不为 String 类型并且数据中 id 和 name 的值没有相同的时候会报如下错误 ===&gt; 如图 简单的解释下这个报错的意思——是指你的 nodes 数据中 id 或 name 有相同。 有需要详细解释的欢迎发邮件给我 601709253@qq.com]]></content>
  </entry>
  <entry>
    <title><![CDATA[iframe]]></title>
    <url>%2Fiframe%2F</url>
    <content type="text"><![CDATA[简单阐述下 Html 标签 iframeMDN 上的定义HTML 内联框架元素 iframe 表示嵌套的浏览上下文，有效地将另一个 HTML 页面嵌入到当前页面中。 我的理解iframe 就是在 Html 页面内再嵌套一个页面，可以做成浮窗的效果。 iframe 常用属性: frameborder :是否显示边框，1(yes),0(no) height :框架作为一个普通元素的高度，建议在使用 css 设置。 width :框架作为一个普通元素的宽度，建议使用 css 设置。 name :框架的名称，window.frames[name]时专用的属性。 scrolling :框架的是否滚动。yes,no,auto。 src ：内框架的地址，可以使页面地址，也可以是图片的地址。 srcdoc ： 用来替代原来 HTML body 里面的内容。但是 IE 不支持, 不过也没什么卵用 sandbox : 对 iframe 进行一些列限制，IE10+支持 iframe 使用条件我们通常使用 iframe 最基本的特性，就是能自由操作 iframe 和父框架的内容(DOM). 但前提条件是同域. 如果跨域顶多只能实现页面跳转 window.location.href. 怎么来判断是否跨域了呢？最直观简单的方式，就是比较 iframe 标签中的 src 属性的值和 iframe 所在页面的地址栏中的地址域名是否相同（主要看首部是否一样） for example： 1234567891011121314A:&lt;iframe id="mainIframe" name="mainIframe" src="/main.html" frameborder="0" scrolling="auto"&gt;&lt;/iframe&gt;B:&lt;iframe id="mainIframe" name="mainIframe" src="http://www.baidu.com" frameborder="0" scrolling="auto"&gt;&lt;/iframe&gt; 使用 A 时，因为同域，父页面可以对子页面进行改写,反之亦然。使用 B 时，不同域，父页面没有权限改动子页面,但可以实现页面的跳转 直接上干货代码，可以自己复制后，在自己的电脑本地测试index.html 文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt; &lt;title&gt;main&lt;/title&gt; &lt;style type="text/css"&gt; body &#123; box-sizing: border-box; margin: 0; background-color: #203048; &#125; .title &#123; position: absolute; top: 10px; left: 10px; font-weight: bold; font-size: 2em; color: #fff; &#125; .function_btn &#123; width: 100%; height: 30px; margin: 10px 0; display: flex; justify-content: center; align-items: center; &#125; .function_btn &gt; a &#123; margin-right: 20px; text-decoration: none; color: #fff; opacity: 0.7; &#125; iframe &#123; float: left; width: 48%; height: 500px; margin-left: 1%; /* border: 1px solid #eee; */ /* background: #ddd; */ display: table-cell; &#125; footer &#123; position: fixed; bottom: 20px; width: 100%; text-align: center; color: #fff; opacity: 0.7; &#125; &lt;/style&gt; &lt;script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; var gg = "这是main.html变量"; function ggMM() &#123; console.log(gg); &#125; function callIframeMethod() &#123; // js document.getElementById("frame").contentWindow.test(); // jq $("#frame")[0].contentWindow.test(); //用jquery调用需要加一个[0] $("#frame")[0] .contents() .text(); &#125; function callIframeField() &#123; // 以下两种方法可以达到同样的效果 console.log($("#frame")[0].contentWindow.ff); console.log(frame.window.ff); &#125; function callIframeHtml() &#123; // 以下两种方法可以达到同样的效果 console.log( $("#frame")[0] .contentWindow.$("#dd") .val() ); console.log(frame.window.$("#dd").val()); var t = document .getElementById("frame") .contentWindow.document.getElementById("dd"); console.log(t); // var t = document.getElementById('frame').contentWindow.document.getElementById('dd'); //console.log($("#frame")[0].contentWindow.document.getElementById("dd").value); //console.log($("#frame")[0].contentWindow.document.getElementById("dd").value); &#125; function giveParameter() &#123; $("#frame")[0].contentWindow.hellobaby = "dsafdsafsdafsdafsdafsdafsadfsadfsdafsadfdsaffdsaaaaaaaaaaaaa"; &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;span class="title"&gt;Index页面&lt;/span&gt; &lt;div class="function_btn"&gt; &lt;a href="javascript:void(0);" onclick="giveParameter(); return false;" &gt;参数传递&lt;/a &gt; &lt;a href="javascript:void(0);" onclick="callIframeMethod(); return false;" &gt;调用子iframe方法&lt;/a &gt; &lt;a href="javascript:void(0);" onclick="callIframeField(); return false;" &gt;调用子iframe变量&lt;/a &gt; &lt;a href="javascript:void(0);" onclick="callIframeHtml(); return false;" &gt;调用子iframe组件&lt;/a &gt; &lt;/div&gt; &lt;iframe id="frame" name="frame" src="frame.html" frameborder="0"&gt;&lt;/iframe&gt; &lt;iframe id="newFrame" name="newFrame" src="newFrame.html" frameborder="0" &gt;&lt;/iframe&gt; &lt;footer&gt;有问题请发邮箱: 18833527317@139.com&lt;/footer&gt; &lt;/body&gt;&lt;/html&gt; frame.html123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt; &lt;title&gt;frame&lt;/title&gt; &lt;style type="text/css"&gt; body &#123; background-color: #405678; &#125; a &#123; display: block; line-height: 30px; text-decoration: none; color: #fff; &#125; #dd &#123; width: 200px; height: 40px; line-height: 40px; border-radius: 3px; border-style: none; &#125; h1 &#123; color: #fff; opacity: 0.7; &#125; &lt;/style&gt; &lt;script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; var ff = "adfdasfdsafdsafdsaf"; function test() &#123; console.log($("#dd").val()); &#125; function callMainField() &#123; console.log(parent.gg); &#125; function callMainMethod() &#123; parent.ggMM(); &#125; function callMainHtml() &#123; console.log(parent.$("#frame").attr("id")); &#125; function getParameter() &#123; console.log(window.hellobaby); &#125; function ss() &#123; console.log("这是frame方法"); console.log(ff); &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;frame&lt;/h1&gt; &lt;a href="javascript:void(0);" onclick="getParameter(); return false;" &gt;接受参数&lt;/a &gt; &lt;a href="javascript:void(0);" onclick="callMainMethod(); return false;" &gt;调用父级方法，并且打印父级变量&lt;/a &gt; &lt;a href="javascript:void(0);" onclick="callMainField(); return false;" &gt;调用主窗口变量&lt;/a &gt; &lt;a href="javascript:void(0);" onclick="callMainHtml(); return false;" &gt;调用子iframe组件&lt;/a &gt; &lt;input id="dd" type="text" value="frame页面的input的value值" /&gt; &lt;/body&gt;&lt;/html&gt; newFrame 页面1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt; &lt;title&gt;在frame里嵌套frame&lt;/title&gt; &lt;style type="text/css"&gt; body &#123; background-color: #405678; &#125; h1 &#123; color: #fff; opacity: 0.7; &#125; input, a &#123; display: block; line-height: 30px; text-decoration: none; &#125; a &#123; color: #fff; &#125; iframe &#123; float: left; width: 48%; height: 250px; margin-top: 40px; background: #abc; border: 1px solid blue; &#125; #newFrame2 &#123; float: right; &#125; #nn &#123; width: 200px; height: 40px; line-height: 40px; border-radius: 3px; border-style: none; &#125; &lt;/style&gt; &lt;script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; var newFrame = &#123; name: "这是newFrame的变量值" &#125;; function callLevelFrame() &#123; var ff = parent.$("#frame")[0].contentWindow.ff; parent.$("#frame")[0].contentWindow.ss(); console.log('parent.$("#frame")[0].contentWindow.ff: ' + ff); &#125; function callLevelFrame1() &#123; console.log($("#newFrame1")[0].contentWindow.iframe1); $("#newFrame1")[0].contentDocument.querySelector( "input" ).style.background = "red"; $("#newFrame1")[0].contentDocument.querySelector("input").style.color = "white"; &#125; function frameFn() &#123; console.log("这是frame里面的方法franmeFn"); &#125; $(function() &#123; // setTimeout(function()&#123; // // console.log(parent.$("#frame")) // // console.log(parent.$("#frame")[0].contentWindow.ss()) // // console.log(parent.document.getElementById('frame').contentWindow.ss()); // &#125;,500) &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;newFrame&lt;/h1&gt; &lt;a href="#" onClick="callLevelFrame();"&gt;调用兄弟iframe&lt;/a&gt; &lt;a href="#" onClick="callLevelFrame1();" &gt;调用自己的子页面iframe1变量并且改变背景色为红色&lt;/a &gt; &lt;input id="nn" type="text" value="newFrame页面的input的value值" /&gt; &lt;iframe id="newFrame1" name="newFrame1" src="newFrame1.html" frameborder="0" &gt;&lt;/iframe&gt; &lt;iframe id="newFrame2" name="newFrame2" src="newFrame2.html" frameborder="0" &gt;&lt;/iframe&gt; &lt;/body&gt;&lt;/html&gt; newFrame11234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt; &lt;title&gt;newFrame1&lt;/title&gt; &lt;style type="text/css"&gt; body &#123; background-color: rbg(66, 182, 246); display: flex; flex-direction: column; justify-content: space-around; &#125; a &#123; display: block; line-height: 30px; color: #ee0000; text-decoration: none; &#125; #nn &#123; width: 200px; height: 40px; line-height: 40px; border-radius: 3px; border-style: none; &#125; &lt;/style&gt; &lt;script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; var iframe1 = "我是iframe1的变量"; function callnewFramFn() &#123; // js parent.parent.document .getElementById("newFrame") .contentWindow.frameFn(); // jq parent.parent.$("#newFrame")[0].contentWindow.frameFn(); &#125; function callnewFramParam() &#123; console.log( parent.parent.document.getElementById("newFrame").contentWindow .newFrame ); &#125; // $(function()&#123; // setTimeout(function()&#123; // // console.log(parent.parent.$("#newFrame")[0]) // // console.log(parent.$("#newFrame")[0].contentWindow.ss()) // // console.log(parent.document.getElementById('newFrame').contentWindow.ss()); // &#125;,500) // &#125;) function frame1() &#123; console.log(iframe1); parent .$("#newFrame2")[0] .contentWindow.$("#nn2") .val(iframe1); &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;newFrame1&lt;/h1&gt; &lt;div class="function_btn"&gt; &lt;a href="#" onClick="callnewFramFn();"&gt;调用newFram方法&lt;/a&gt; &lt;a href="#" onClick="callnewFramParam();"&gt;调用newFram变量&lt;/a&gt; &lt;/div&gt; &lt;input id="nn" type="text" value="这是newFrame1的input值" /&gt; &lt;/body&gt;&lt;/html&gt; newFrame2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt; &lt;title&gt;newFrame1&lt;/title&gt; &lt;style type="text/css"&gt; body &#123; background-color: rbg(66, 182, 246); display: flex; flex-direction: column; justify-content: space-around; &#125; a &#123; display: block; line-height: 30px; color: #ee0000; text-decoration: none; &#125; #nn2 &#123; width: 200px; height: 40px; line-height: 40px; border-radius: 3px; border-style: none; &#125; .function_btn &#123; width: 203px; height: 60px; &#125; &lt;/style&gt; &lt;script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; var iframe1 = "我是iframe2的变量"; function callnewFramFn1() &#123; parent.$("#newFrame1")[0].contentWindow.frame1(); console.log(parent.$("#newFrame1")); &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;newFrame2&lt;/h1&gt; &lt;div class="function_btn"&gt; &lt;a href="#" onClick="callnewFramFn1();"&gt;调用newFram1方法&lt;/a&gt; &lt;/div&gt; &lt;input id="nn2" type="text" value="这是newFrame1的input值" /&gt; &lt;/body&gt;&lt;/html&gt; 打开后的页面效果截图 附件下载地址:(http://lc-zltjehai.cn-n1.lcfile.com/545ea1f9e6c5a8680d49/iframe.rar)]]></content>
  </entry>
  <entry>
    <title><![CDATA[Markdown简易语法]]></title>
    <url>%2FMarkdown%2F</url>
    <content type="text"><![CDATA[1.什么是 MarkdownMarkdown 是一种纯文本格式的标记语言。通过简单的标记语法，它可以使普通文本内容具有一定的格式。深入学习请移步 Markdown 官网 2.Markdown 语法的优缺点优点： 1、因为是纯文本，所以只要支持 Markdown 的地方都能获得一样的编辑效果，可以让作者摆脱排版的困扰，专心写作。2、操作简单。比如:WYSIWYG 编辑时标记个标题，先选中内容，再点击导航栏的标题按钮，选择几级标题。要三个步骤。而 Markdown 只需要在标题内容前加#即可 缺点： 1、需要记一些语法（当然，是很简单。五分钟学会）。2、有些平台不支持 Markdown 编辑模式。 3.Markdown 简易指令，轻松上手标题写法超链接名 # 这是一级标题 ## 这是二级标题 ### 这是三级标题 #### 这是四级标题 ##### 这是五级标题 ###### 这是六级标题]]></content>
      <tags>
        <tag>针对于刚入门使用不熟悉的，语法文档</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo入门学习]]></title>
    <url>%2FHexostudy%2F</url>
    <content type="text"><![CDATA[什么是 HexoHexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 Hexo 搭建步骤 安装 Git bash (非必须,主要针对于 windows 中不习惯使用 cmd ,编译器是 VsCode 也可以不用这个) 安装 Node.js 安装 Hexo Github 上创建个人仓库 生成 SSH 添加到 GitHub 将 hexo 部署到 GitHub 将 yourname.github.io 绑定到个人域名 发布文章 1. 安装 GitGit 是目前世界上最先进的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。也就是用来管理你的 hexo 博客文章，上传到 GitHub 的工具。Git 非常强大，我觉得建议每个人都去了解一下。廖雪峰老师的 Git 教程写的非常好，大家可以了解一下。Git 教程 windows：到 git 官网上下载,Download git,下载后会有一个 Git Bash 的命令行工具，以后就用这个工具来使用 git。 linux：对 linux 来说实在是太简单了，因为最早的 git 就是在 linux 上编写的，只需要一行代码 1$ sudo apt-get install git 安装好后，用 git –version 来查看一下版本 2.安装 node.jsHexo 是基于 nodeJS 编写的，所以需要安装一下 nodeJs 和里面的 npm 工具。 windows：nodejs 选择 LTS 版本就行了。 linux： 12sudo apt-get install nodejssudo apt-get install npm 安装完后，打开命令行 12345node -vnpm -vsudo apt-get install nodejssudo apt-get install npm 检查一下有没有安装成功 顺便说一下，windows 在 git 安装完后，就可以直接使用 git bash 来敲命令行了，不用自带的 cmd，cmd 有点难用。 3.安装 Hexo前面 git 和 nodejs 安装好后，就可以安装 hexo 了，你可以先创建一个文件夹 blog，然后 cd 到这个文件夹下（或者在这个文件夹下直接右键 git bash 打开）。 输入命令 12npm install -g hexo-cli 安装完成之后,有两种方法生成 Hexo demo 1.自定义创建好一个文件夹，然后在该文件夹下的根目录中打开 Git bash ,或者你使用的编译器是 VS Code 可以直接将该文件夹托人到 VS Code 编辑器中，然后使用命令 Ctrl + ~ 打开终端窗口,输入 1hexo init (简写 hexo i) 只需等待 demo 自己加载完即可 2.相对于方法一来说比较简便,使用 一行代码直接在你当前目录下生成 Hexo Demo 1hexo init myBlog 其中 myBlog 是你 Hexo demo 的文件夹的名字。 新建完成后，指定文件夹目录下有： node_modules: 依赖包public：存放生成的页面scaffolds：生成文章的一些模板source：用来存放你的文章themes：主题 _config.yml: 博客的配置文件 再使用命令 1hexo g (这个是简写,原本的代码为 hexo generate) 然后再使用 1hexo s (这个是简写,原本的代码为 hexo server / hexo serve ),默认的端口是 4000,你也可以写成 hexo s -p 8080 ,自己定义本地起 hexo 服务的端口号 这样你就可以看到在 hexo 本地跑起来的服务了,特别说明下,在本地展示的效果方便于开发，可以实时的看到你所修改的博客界面。 4.如何将 github 和 hexo 联系起来?1. 你需要先配置一下 SSH key为什么要配置这个呢？因为你提交代码肯定要拥有你的 github 权限才可以，但是直接使用用户名和密码太不安全了，所以我们使用 ssh key 来解决本地和服务器的连接问题。 a. 重新打开 Git 命令窗口，输入下面命令: 1ssh-keygen -t rsa -C "git@github.com" //Github 的注册邮箱地址 b. 一路 Enter 过来就好，得到的信息如下: 1Your public key has been saved in /c/Users/user/.ssh/id_rsa.pub. 找到该文件并打开，复制里面的所有内容，然后进入 Sign in to GitHub：https://github.com/settings/ssh c. 依次执行下面步骤:点击 New SSH key —— Title：blog —— Key：输入刚才复制的 —— Add SSH key d. 测试一下是否成功,输入下方命令: 1ssh -T git@github.com //git@github.com 只要看到返回的信息中带有如下内容就说明成功了, 1Hi SquabbyZ! You've successfully authenticated 2.设置 Git 的 user name 和 email最好是在你当前 Hexo Demo 的目录下 依次执行下面的两个指令 12git config --global user.name "SquabbyZ" // 你的 github 用户名，非昵称git config --global user.email "git@github.com" // 填写你的 github 注册邮箱 3.修改参数及配置 deploy-git a.修改参数下面来简单介绍下 Hexo 项目中的配置文件 _config.ymlHexo 中的一些基本配置都需要在该文件里完成,这里只介绍简单的一些配置项 ① title: SquabbyZ 的小黑屋 //你自己博客的名字② subtitle: 技术博客 //博客副标题③ description: 一只致力于成为全栈的小胖纸 //你博客的描述④ author: Squabby Zhu //博客的作者 然后把配置文件下拉到最低下后,还有一些配置项需要去修改 ⑤ theme: next //主题文件夹的名字,关于更换主题内容可以直接点击更换主题⑥ deploy: //这里的配置,就是跟 Github 上你要把这个 demo 存入到仓库的配置type: git //类型 githubrepo: ssh://git@github.com/SquabbyZ/SquabbyZ.github.io.git//仓库地址，必须这样写 ssh://git@github.com/yourname/yourname.github.io.git ,注意这里的地址不是昵称。branch: master //仓库分支为:主分支上面这些配置好后,可以在 hexo 本地服务中看到除了 deploy 中修改外的其他修改的内容。 b.使用 deploy-git 工具,将本地做好的博客上传到 github 仓库中，更新仓库展示内容 先下载插件 deploy-git，指令如下: 1npm install hexo-deployer-git --save 插件下载完成后,按顺序输入如下命令: ① hexo clean //清除了你之前生成的东西，也可以不加② hexo generate //顾名思义，生成静态文章，可以用 hexo g 缩写③ hexo deploy //部署文章，可以用 hexo d 缩写]]></content>
      <tags>
        <tag>主要介绍 Hexo个人博客模板的搭建与Github的连通，以及个人域名绑定</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HelloWorld]]></title>
    <url>%2Fhelloworld%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
