<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[同心圆坐标算法]]></title>
    <url>%2FechartsGraph%2F</url>
    <content type="text"><![CDATA[前言由于项目中要搭建人物关系图谱，基于定制化不是很强，并且要求在短时间内实现同心圆人物关系图的效果，因此，我采用的是基于 Echarts V4 版本和 JQuery V3.4.0 来先实现的 graph 图,根据自己的摸索，研究出来了，echarts 的 graph 图坐标系的分布： 先来阐述下，Echarts 的 graph 图的坐标系的展示假设我们取的展示 echarts 的盒子的大小为 400pxX400pxecharts 中 graph 的坐标系是左上角为 (0,0)点，右下角为 (400,400)根据这个坐标位置的关系，我们可以确定要做同心圆的中心点的位置为 (200,200),话不多说，先来个干货,呈上一段动态生成的 nodes 和 links 的基本 demo 数据 nodes 的数据的 id 一定要是字符串的类型，不要是数字 否则会出现如图的效果点点击这里 12345678910111213141516171819202122var nodes = []; var links = []; for (var i = 0; i &lt; 6; i++) &#123; nodes.push(&#123; id: `$&#123;i&#125;`, //这个 ID 在 nodes 数据中必须唯一，在 links 中可以重复出现 name: `demo$&#123;i&#125;`, //每个节点显示的名字 symbolSize: 20, //节点在图中显示的大小 value: 20 //每个节点的数据大小，一般情况下保持和每个节点的 symbolSize 的值一致 &#125;); &#125; nodes.forEach((ele, index, arr) =&gt; &#123; if (index != arr.length - 1) &#123; links.push(&#123; id: `$&#123;index * 2&#125;`, //这个 ID 在 links 必须唯一，但是只是作为每条数据的 ID 而已，不影响图展示 name: `demo$&#123;index&#125;---demo$&#123;index * 1 + 1 * 1&#125;`, //节点和节点的连接线上显示的数据内容 source: `$&#123;index&#125;`, //起始点(来源) target: `$&#123;index * 1 + 1 * 1&#125;` &#125;); &#125; &#125;); 上面的代码是最基本的数据，但是要注意一点，如果你在 option 中 的 series 数组下的 layout 的属性值不写，或者其值为 none 的时候，会报错 Uncaught TypeError: Cannot read property ‘off’ of undefined echarts 中 option 的 series 的 layout 的默认属性值默认为 none这个问题的主要原因,就是在于 nodes 数据上,对于初次使用 echarts 的 graph 图的同学来说，上来就给 nodes 数据加入 x , y 坐标的值，难度系数比较大，因为不懂如何通过自己算出每个点的坐标来进行展示，所以就会报上面的问题，还有可能是你的 nodes 数据中的 某个点的 x 或者 y 出现 NAN 的情况,所以想熟悉下的童鞋，在没有给 nodes 数据传入 x , y 的时候，一定要设置为 “force” 或者 “circular”. 上个完整的前端代码，以供同学们学习：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8" /&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge" /&gt; &lt;title&gt;echarts 同心圆图&lt;/title&gt; &lt;/head&gt; &lt;script src="./echarts.js"&gt;&lt;/script&gt; &lt;script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"&gt;&lt;/script&gt; &lt;style&gt; body &#123; box-sizing: border-box; margin: 0; width: 100%; height: 100%; &#125; &lt;/style&gt; &lt;body&gt; &lt;div id="graph" style="width:vw;height:100vh;"&gt;&lt;/div&gt; &lt;script&gt; $(function() &#123; var nodes = []; var links = []; for (var i = 0; i &lt; 6; i++) &#123; nodes.push(&#123; id: `$&#123;i&#125;`, //这个 ID 在 nodes 数据中必须唯一，在 links 中可以重复出现 name: `demo$&#123;i&#125;`, //每个节点显示的名字 symbolSize: 20, //节点在图中显示的大小 value: 20 //每个节点的数据大小，一般情况下保持和每个节点的 symbolSize 的值一致 &#125;); &#125; nodes.forEach((ele, index, arr) =&gt; &#123; if (index != arr.length - 1) &#123; links.push(&#123; id: index * 2 + 3, //这个 ID 在 links 必须唯一，但是只是作为每条数据的 ID 而已，不影响图展示 name: `demo$&#123;index&#125;---demo$&#123;index * 1 + 1 * 1&#125;`, //节点和节点的连接线上显示的数据内容 source: `$&#123;index&#125;`, //起始点(来源) target: `$&#123;index * 1 + 1 * 1&#125;` &#125;); &#125; &#125;); getGraph(nodes, links); &#125;); function getGraph(nodes, links) &#123; var graph = &#123; nodes: nodes, links: links &#125;; myChart = echarts.init(document.getElementById("graph")); option = &#123; title: &#123; //标题 text: "同心圆关系图", //标题展示的内容 top: "10", //标题定位，距顶部的距离为10 left: "center" //距左边的值为 "center" (中间) &#125;, tooltip: &#123; //修改划上去的edge显示内容 formatter: function(param) &#123; if (param.dataType == "edge") &#123; return `$&#123;param.data.source&#125;&gt;$&#123;param.data.target&#125;`; &#125; return; &#125;, rich: &#123; color: "black" &#125; &#125;, animationDuration: 1500, //初始动画的时长，支持回调函数，可以通过每个数据返回不同的 delay 时间实现更戏剧的初始动画效果 animationEasingUpdate: "quinticInOut", //数据更新动画的缓动效果 series: [ &#123; type: "graph", //展示的类型为关系图 // layout: "force", layout: "circular", //图的布局。'none' 不采用任何布局，使用节点中提供的 x， y 作为节点的位置。'circular' 采用环形布局，'force' 采用力引导布局,[ default: 'none' ] roam: true, //是否开启鼠标缩放和平移漫游。默认不开启。如果只想要开启缩放或者平移，可以设置成 'scale' 或者 'move'。设置成 true 为都开启,[ default: false ] draggable: true, //节点是否可拖拽，只在使用力引导布局的时候有用,[ default: false ] focusNodeAdjacency: true, //是否在鼠标移到节点上的时候突出显示节点以及节点的边和邻接节点,[ default: false ] data: graph.nodes, //节点数据 links: graph.links, //连线数据 symbol: "circle", //关系图节点标记的图形。ECharts 提供的标记类型包括 'circle', 'rect', 'roundRect', 'triangle', 'diamond', 'pin', 'arrow', 'none',可以通过 'image://url' 设置为图片，其中 URL 为图片的链接，或者 dataURI,[ default: 'circle' ] edgeSymbol: ["circle", "arrow"], //边两端的标记类型，可以是一个数组分别指定两端，也可以是单个统一指定。默认不显示标记，常见的可以设置为箭头,[ default: ['none', 'none'] ] edgeSymbolSize: 10, //边两端的标记大小，可以是一个数组分别指定两端，也可以是单个统一指定。可以是数组[10,10],[ default: 10 ] cursor: "pointer", //鼠标悬浮时在图形元素上时鼠标的样式是什么。同 CSS 的 cursor,[ default: 'pointer' ] itemStyle: &#123; //图形样式 normal: &#123; color: "#06d55e", borderColor: "#fff", borderWidth: 1, shadowBlur: 10, shadowColor: "rgba(0,0,0,0.3)" &#125; &#125;, label: &#123; //图形上的文本标签，可用于说明图形的一些数据信息，比如值，名称等，label选项在 ECharts 2.x 中放置于itemStyle下，在 ECharts 3 中为了让整个配置项结构更扁平合理，label 被拿出来跟 itemStyle 平级，并且跟 itemStyle 一样拥有 emphasis 状态。 show: true, position: "inside", formatter: "&#123;b&#125;", fontSize: 20, rich: &#123; b: &#123; color: "#fff" &#125; &#125; &#125;, lineStyle: &#123; //关系边的公用线条样式。其中 lineStyle.color 支持设置为'source'或者'target'特殊值，此时边会自动取源节点或目标节点的颜色作为自己的颜色。 color: "source", curveness: 0.1 //边的曲度，支持从 0 到 1 的值，值越大曲度越大 &#125;, edgeLabel: &#123; //连线上显示的内容的设置 color: "black", position: "middle" //连线上的内容显示的位置 &#125;, emphasis: &#123; //hover展示的效果 lineStyle: &#123; width: 3 &#125;, label: &#123; show: false &#125; &#125; &#125; ] &#125;; myChart.setOption(option); window.onresize = function() &#123; //随着浏览器视窗的变化，自适应 myChart.resize(); &#125;; &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 展示的图片效果 加入同心圆算法上干货: 基础算法12345678910111213141516171819//同心圆关系图坐标点计算方法function getPoint(r, ox, oy, count) &#123; var point = []; //结果 /* * 求圆周上等分点的坐标 * ox,oy为圆心坐标 * r为半径 * count为等分个数 */ var radians = (Math.PI / 180) * Math.round(360 / count), //弧度 i = 0; for (; i &lt; count; i++) &#123; var x = ox + r * Math.sin(radians * i), y = oy + r * Math.cos(radians * i); point.unshift(&#123; x: x, y: y &#125;); //为保持数据顺时针 &#125; return point;&#125; 这个是基本的同心圆坐标的数学算法，下面我们把上面的代码进行改造下 处理后算法12345678910111213141516171819202122232425262728function getPoint(centerId, nodes) &#123; /* * 求圆周上等分点的坐标 * ox,oy为圆心坐标 * r为半径 */ var ox = window.innerWidth / 2; var oy = window.innerHeight / 2; var r = ox &gt; oy ? oy - 100 : ox - 100; var newNodes = []; var radians = (Math.PI / 180) * Math.round(360 / (nodes.length - 1)), //弧度 i = 0; for (; i &lt; nodes.length; i++) &#123; if (nodes[i].id == centerId) &#123; newNodes.unshift(nodes[i]); &#125; else &#123; newNodes.push(nodes[i]); &#125; &#125; for (var j = 0; j &lt; newNodes.length; j++) &#123; newNodes[j].x = ox + r * Math.sin(radians * j); newNodes[j].y = oy + r * Math.cos(radians * j); &#125; //中心点位更新 newNodes[0].x = ox; newNodes[0].y = oy; return newNodes || null; &#125; 直接上最终代码:记得把 layout 的值修改为 “none” 或者直接注释/删除掉 layout 属性 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8" /&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge" /&gt; &lt;title&gt;echarts 同心圆图&lt;/title&gt; &lt;/head&gt; &lt;script src="./echarts.js"&gt;&lt;/script&gt; &lt;script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"&gt;&lt;/script&gt; &lt;style&gt; body &#123; box-sizing: border-box; margin: 0; width: 100%; height: 100%; &#125; &lt;/style&gt; &lt;body&gt; &lt;div id="graph" style="width:vw;height:100vh;"&gt;&lt;/div&gt; &lt;script&gt; $(function() &#123; var nodes = []; var links = []; for (var i = 0; i &lt; 6; i++) &#123; nodes.push(&#123; id: `$&#123;i&#125;`, //这个 ID 在 nodes 数据中必须唯一，在 links 中可以重复出现 name: `demo$&#123;i&#125;`, //每个节点显示的名字 symbolSize: 20, //节点在图中显示的大小 value: 20 //每个节点的数据大小，一般情况下保持和每个节点的 symbolSize 的值一致 // x: 662.0767566415067*i, // y: 71.20162612375115 &#125;); &#125; nodes.forEach((ele, index, arr) =&gt; &#123; if (index != arr.length - 1) &#123; links.push(&#123; id: index * 2 + 3, //这个 ID 在 links 必须唯一，但是只是作为每条数据的 ID 而已，不影响图展示 name: `demo$&#123;index&#125;---demo$&#123;index * 1 + 1 * 1&#125;`, //节点和节点的连接线上显示的数据内容 source: `$&#123;index&#125;`, //起始点(来源) target: `$&#123;index * 1 + 1 * 1&#125;` &#125;); &#125; &#125;); nodes = getPoint("1", nodes); if (nodes) &#123; getGraph(nodes, links); &#125; &#125;); function getGraph(nodes, links) &#123; var graph = &#123; nodes: nodes, links: links &#125;; myChart = echarts.init(document.getElementById("graph")); option = &#123; title: &#123; //标题 text: "同心圆关系图", //标题展示的内容 top: "10", //标题定位，距顶部的距离为10 left: "center" //距左边的值为 "center" (中间) &#125;, tooltip: &#123; //修改划上去的edge显示内容 formatter: function(param) &#123; if (param.dataType == "edge") &#123; return `$&#123;param.data.source&#125;&gt;$&#123;param.data.target&#125;`; &#125; return; &#125;, rich: &#123; color: "black" &#125; &#125;, animationDuration: 1500, //初始动画的时长，支持回调函数，可以通过每个数据返回不同的 delay 时间实现更戏剧的初始动画效果 animationEasingUpdate: "quinticInOut", //数据更新动画的缓动效果 series: [ &#123; type: "graph", //展示的类型为关系图 // layout: "force", layout: "none", //图的布局。'none' 不采用任何布局，使用节点中提供的 x， y 作为节点的位置。'circular' 采用环形布局，'force' 采用力引导布局,[ default: 'none' ] roam: true, //是否开启鼠标缩放和平移漫游。默认不开启。如果只想要开启缩放或者平移，可以设置成 'scale' 或者 'move'。设置成 true 为都开启,[ default: false ] draggable: true, //节点是否可拖拽，只在使用力引导布局的时候有用,[ default: false ] focusNodeAdjacency: true, //是否在鼠标移到节点上的时候突出显示节点以及节点的边和邻接节点,[ default: false ] data: graph.nodes, //节点数据 links: graph.links, //连线数据 symbol: "circle", //关系图节点标记的图形。ECharts 提供的标记类型包括 'circle', 'rect', 'roundRect', 'triangle', 'diamond', 'pin', 'arrow', 'none',可以通过 'image://url' 设置为图片，其中 URL 为图片的链接，或者 dataURI,[ default: 'circle' ] edgeSymbol: ["circle", "arrow"], //边两端的标记类型，可以是一个数组分别指定两端，也可以是单个统一指定。默认不显示标记，常见的可以设置为箭头,[ default: ['none', 'none'] ] edgeSymbolSize: 10, //边两端的标记大小，可以是一个数组分别指定两端，也可以是单个统一指定。可以是数组[10,10],[ default: 10 ] cursor: "pointer", //鼠标悬浮时在图形元素上时鼠标的样式是什么。同 CSS 的 cursor,[ default: 'pointer' ] itemStyle: &#123; //图形样式 normal: &#123; color: "#06d55e", borderColor: "#fff", borderWidth: 1, shadowBlur: 10, shadowColor: "rgba(0,0,0,0.3)" &#125; &#125;, label: &#123; //图形上的文本标签，可用于说明图形的一些数据信息，比如值，名称等，label选项在 ECharts 2.x 中放置于itemStyle下，在 ECharts 3 中为了让整个配置项结构更扁平合理，label 被拿出来跟 itemStyle 平级，并且跟 itemStyle 一样拥有 emphasis 状态。 show: true, position: "inside", formatter: "&#123;b&#125;", fontSize: 20, rich: &#123; b: &#123; color: "#fff" &#125; &#125; &#125;, lineStyle: &#123; //关系边的公用线条样式。其中 lineStyle.color 支持设置为'source'或者'target'特殊值，此时边会自动取源节点或目标节点的颜色作为自己的颜色。 color: "source", curveness: 0.1 //边的曲度，支持从 0 到 1 的值，值越大曲度越大 &#125;, edgeLabel: &#123; //连线上显示的内容的设置 color: "black", position: "middle" //连线上的内容显示的位置 &#125;, emphasis: &#123; //hover展示的效果 lineStyle: &#123; width: 3 &#125;, label: &#123; show: false &#125; &#125; &#125; ] &#125;; myChart.setOption(option); window.onresize = function() &#123; //随着浏览器视窗的变化，自适应 myChart.resize(); &#125;; &#125; function getPoint(centerId, nodes) &#123; /* * 求圆周上等分点的坐标 * ox,oy为圆心坐标 * r为半径 *centerId为想要作为中心点的节点的ID *nodes为要传入到echarts中的节点数据 */ var ox = window.innerWidth / 2; var oy = window.innerHeight / 2; var r = ox &gt; oy ? oy - 100 : ox - 100; //整个同心圆的大小半径 var newNodes = []; //计算完的结果 var radians = (Math.PI / 180) * Math.round(360 / (nodes.length - 1)), //弧度 i = 0; for (; i &lt; nodes.length; i++) &#123; //这个for循环是让要放在中心点的那个点，放在数组的第一位，为后面的将中心点的坐标赋值给它提供便利 if (nodes[i].id == centerId) &#123; newNodes.unshift(nodes[i]); //中心点坐标放到第一位的方法 &#125; else &#123; newNodes.push(nodes[i]); //正常的 push &#125; &#125; for (var j = 1; j &lt; newNodes.length; j++) &#123; //这里是将数据除了索引为0的数组元素添加计算好的 x y 坐标 newNodes[j].x = ox + r * Math.sin(radians * j); newNodes[j].y = oy + r * Math.cos(radians * j); &#125; //中心节点的坐标 newNodes[0].x = ox; newNodes[0].y = oy; return newNodes || null; &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 最后的效果图为: 造数据的时候，nodes 的 id 不为 String 类型并且数据中 id 和 name 的值没有相同的时候会报如下错误 ===&gt; 如图 简单的解释下这个报错的意思——是指你的 nodes 数据中 id 或 name 有相同。 有需要详细解释的欢迎发邮件给我 601709253@qq.com]]></content>
  </entry>
  <entry>
    <title><![CDATA[iframe]]></title>
    <url>%2Fiframe%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[Markdown简易语法]]></title>
    <url>%2FMarkdown%2F</url>
    <content type="text"><![CDATA[1.什么是 MarkdownMarkdown 是一种纯文本格式的标记语言。通过简单的标记语法，它可以使普通文本内容具有一定的格式。深入学习请移步 Markdown 官网 2.Markdown 语法的优缺点优点： 1、因为是纯文本，所以只要支持 Markdown 的地方都能获得一样的编辑效果，可以让作者摆脱排版的困扰，专心写作。2、操作简单。比如:WYSIWYG 编辑时标记个标题，先选中内容，再点击导航栏的标题按钮，选择几级标题。要三个步骤。而 Markdown 只需要在标题内容前加#即可 缺点： 1、需要记一些语法（当然，是很简单。五分钟学会）。2、有些平台不支持 Markdown 编辑模式。 3.Markdown 简易指令，轻松上手标题写法超链接名 # 这是一级标题 ## 这是二级标题 ### 这是三级标题 #### 这是四级标题 ##### 这是五级标题 ###### 这是六级标题]]></content>
      <tags>
        <tag>针对于刚入门使用不熟悉的，语法文档</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo入门学习]]></title>
    <url>%2FHexostudy%2F</url>
    <content type="text"><![CDATA[什么是 HexoHexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 Hexo 搭建步骤 安装 Git bash (非必须,主要针对于 windows 中不习惯使用 cmd ,编译器是 VsCode 也可以不用这个) 安装 Node.js 安装 Hexo Github 上创建个人仓库 生成 SSH 添加到 GitHub 将 hexo 部署到 GitHub 将 yourname.github.io 绑定到个人域名 发布文章 1. 安装 GitGit 是目前世界上最先进的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。也就是用来管理你的 hexo 博客文章，上传到 GitHub 的工具。Git 非常强大，我觉得建议每个人都去了解一下。廖雪峰老师的 Git 教程写的非常好，大家可以了解一下。Git 教程 windows：到 git 官网上下载,Download git,下载后会有一个 Git Bash 的命令行工具，以后就用这个工具来使用 git。 linux：对 linux 来说实在是太简单了，因为最早的 git 就是在 linux 上编写的，只需要一行代码 1$ sudo apt-get install git 安装好后，用 git –version 来查看一下版本 2.安装 node.jsHexo 是基于 nodeJS 编写的，所以需要安装一下 nodeJs 和里面的 npm 工具。 windows：nodejs 选择 LTS 版本就行了。 linux： 12sudo apt-get install nodejssudo apt-get install npm 安装完后，打开命令行 12345node -vnpm -vsudo apt-get install nodejssudo apt-get install npm 检查一下有没有安装成功 顺便说一下，windows 在 git 安装完后，就可以直接使用 git bash 来敲命令行了，不用自带的 cmd，cmd 有点难用。 3.安装 Hexo前面 git 和 nodejs 安装好后，就可以安装 hexo 了，你可以先创建一个文件夹 blog，然后 cd 到这个文件夹下（或者在这个文件夹下直接右键 git bash 打开）。 输入命令 12npm install -g hexo-cli 安装完成之后,有两种方法生成 Hexo demo 1.自定义创建好一个文件夹，然后在该文件夹下的根目录中打开 Git bash ,或者你使用的编译器是 VS Code 可以直接将该文件夹托人到 VS Code 编辑器中，然后使用命令 Ctrl + ~ 打开终端窗口,输入 1hexo init (简写 hexo i) 只需等待 demo 自己加载完即可 2.相对于方法一来说比较简便,使用 一行代码直接在你当前目录下生成 Hexo Demo 1hexo init myBlog 其中 myBlog 是你 Hexo demo 的文件夹的名字。 新建完成后，指定文件夹目录下有： node_modules: 依赖包public：存放生成的页面scaffolds：生成文章的一些模板source：用来存放你的文章themes：主题 _config.yml: 博客的配置文件 再使用命令 1hexo g (这个是简写,原本的代码为 hexo generate) 然后再使用 1hexo s (这个是简写,原本的代码为 hexo server / hexo serve ),默认的端口是 4000,你也可以写成 hexo s -p 8080 ,自己定义本地起 hexo 服务的端口号 这样你就可以看到在 hexo 本地跑起来的服务了,特别说明下,在本地展示的效果方便于开发，可以实时的看到你所修改的博客界面。 4.如何将 github 和 hexo 联系起来?1. 你需要先配置一下 SSH key为什么要配置这个呢？因为你提交代码肯定要拥有你的 github 权限才可以，但是直接使用用户名和密码太不安全了，所以我们使用 ssh key 来解决本地和服务器的连接问题。 a. 重新打开 Git 命令窗口，输入下面命令: 1ssh-keygen -t rsa -C "git@github.com" //Github 的注册邮箱地址 b. 一路 Enter 过来就好，得到的信息如下: 1Your public key has been saved in /c/Users/user/.ssh/id_rsa.pub. 找到该文件并打开，复制里面的所有内容，然后进入 Sign in to GitHub：https://github.com/settings/ssh c. 依次执行下面步骤:点击 New SSH key —— Title：blog —— Key：输入刚才复制的 —— Add SSH key d. 测试一下是否成功,输入下方命令: 1ssh -T git@github.com //git@github.com 只要看到返回的信息中带有如下内容就说明成功了, 1Hi SquabbyZ! You've successfully authenticated 2.设置 Git 的 user name 和 email最好是在你当前 Hexo Demo 的目录下 依次执行下面的两个指令 12git config --global user.name "SquabbyZ" // 你的 github 用户名，非昵称git config --global user.email "git@github.com" // 填写你的 github 注册邮箱 3.修改参数及配置 deploy-git a.修改参数下面来简单介绍下 Hexo 项目中的配置文件 _config.ymlHexo 中的一些基本配置都需要在该文件里完成,这里只介绍简单的一些配置项 ① title: SquabbyZ 的小黑屋 //你自己博客的名字② subtitle: 技术博客 //博客副标题③ description: 一只致力于成为全栈的小胖纸 //你博客的描述④ author: Squabby Zhu //博客的作者 然后把配置文件下拉到最低下后,还有一些配置项需要去修改 ⑤ theme: next //主题文件夹的名字,关于更换主题内容可以直接点击更换主题⑥ deploy: //这里的配置,就是跟 Github 上你要把这个 demo 存入到仓库的配置type: git //类型 githubrepo: ssh://git@github.com/SquabbyZ/SquabbyZ.github.io.git//仓库地址，必须这样写 ssh://git@github.com/yourname/yourname.github.io.git ,注意这里的地址不是昵称。branch: master //仓库分支为:主分支上面这些配置好后,可以在 hexo 本地服务中看到除了 deploy 中修改外的其他修改的内容。 b.使用 deploy-git 工具,将本地做好的博客上传到 github 仓库中，更新仓库展示内容 先下载插件 deploy-git，指令如下: 1npm install hexo-deployer-git --save 插件下载完成后,按顺序输入如下命令: ① hexo clean //清除了你之前生成的东西，也可以不加② hexo generate //顾名思义，生成静态文章，可以用 hexo g 缩写③ hexo deploy //部署文章，可以用 hexo d 缩写]]></content>
      <tags>
        <tag>主要介绍 Hexo个人博客模板的搭建与Github的连通，以及个人域名绑定</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HelloWorld]]></title>
    <url>%2Fhelloworld%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
