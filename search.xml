<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[CentosInstallJDK]]></title>
    <url>%2FCentosInstallJDK%2F</url>
    <content type="text"><![CDATA[在 centos 的系统上安装 JDK 查看 yum 中管理的可以使用的 JDK 软件的包列表 1yum search java | grep -i --color JDK 根据显示的列表选择合适的版本,安装 JDK ,我选择的是 “java-1.8.0-openjdk-devel.x86_64” 1yum install java-1.8.0-openjdk-devel.x86_64 一顿安装完成之后,配置环境变量，打开 etc 文件夹下的 profile 文件 1vim /etc/profile 在文件夹内上面的注释下面添加如下的环境配置代码:(找到位置后按 大写的 O,就可以添加一行开始编辑了) 123export JAVA_HOME=/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.71-2.b15.el7_2.x86_64export CLASSPATH=.:$JAVA_HOME/jre/lib/rt.jar:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarexport PATH=$PATH:$JAVA_HOME/bin 4.先按 Esc，然后在输入 “:wq”,回车即可,文件就被保存了,然后执行，让配置生效： 1source /etc/profile 可以在命令行输入 “java -version” 显示出“openjdk version “1.8.0_212”OpenJDK Runtime Environment (build 1.8.0_212-b04)OpenJDK 64-Bit Server VM (build 25.212-b04, mixed mode)“,即为安装成功。]]></content>
  </entry>
  <entry>
    <title><![CDATA[CentosOrder]]></title>
    <url>%2FCentosOrder%2F</url>
    <content type="text"><![CDATA[Centos 学习1. 添加新用户并授权（一） 创建一个 Jack 用户12345cd /homeadduser Jackls 可以看到在 home 目录下生成了一个名字为 Jack 的文件夹 （二） 为 Jack 用户设置密码1passwd Jack 命令行中会弹出 :”Changing password for user Jack.New password: “ 输入你的密码,我在这里设置的密码是：123456,你按回车之后，系统会提示你:”BAD PASSWORD: The password fails the dictionary check - it is too simplistic/systematic”,可以不用理会，这个是告诉你，你设置的密码太简单了,由于我们只是作为测试，所以忽略这个警告。 紧接着就会弹出:”Retype new password:”,意思是让你确认密码。输入完成后系统提示:”passwd: all authentication tokens updated successfully.”,就证明用户密码设置成功。 (三) 新 Jack 用户进行 sudo 操作的授权因为 sudo 命令是在 sudoers 文件中的，我们看一下 sudoers 文件所在的位置 1whereis sudoers 命令行窗口输出的内容就显示出了，我们所要找的文件所在的位置:”sudoers: /etc/sudoers /etc/sudoers.d /usr/share/man/man5/sudoers.5.gz“ （五）查看一下文件的权限1ls -l /etc/sudoers 输出的显示为:”-r–r—–. 1 root root 3938 Apr 11 2018 /etc/sudoers” 可以看到只有只读的权限，这时候我们要加入一个可写的（w）的权限 （六）加入可写的权限1chmod -v u+w /etc/sudoers 命令行显示内容为:”mode of ‘/etc/sudoers’ changed from 0440 (r–r—–) to 0640 (rw-r—–)” （七）把 Jack 用户添加到 sudoers 中1vim /etc/sudoers 打开 sudoers 文件开始编辑 我的腾讯云服务器会提示如下信息: E325: ATTENTIONFound a swap file by the name “/etc/.sudoers.swp”owned by: root dated: Wed Jul 3 09:57:38 2019file name: /etc/sudoersmodified: YESuser name: root host name: VM_0_9_centosprocess ID: 16454While opening file “/etc/sudoers”dated: Wed Jul 3 10:08:11 2019NEWER than swap file! (1) Another program may be editing the same file. If this is the case,be careful not to end up with two different instances of the samefile when making changes. Quit, or continue with caution.(2) An edit session for this file crashed.If this is the case, use “:recover” or “vim -r /etc/sudoers”to recover the changes (see “:help recovery”).If you did this already, delete the swap file “/etc/.sudoers.swp”to avoid this message.“/etc/sudoers” 114L, 3967CPress ENTER or type command to continue 只需要按回车键就可以正常进入到文件的编辑 然后输入 “/“,在之后输入 “All”,然后定位到要修改的内容的位置,在查到的位置上加入 “Jack ALL=(ALL) ALL” 加完之后的效果为： “ ## Allow root to run any commands anywhereroot ALL=(ALL) ALLJack ALL=(ALL) ALL“ 如果是 输入错误了，按 “ctrl + c”,再按 “ctrl + z”,就退出了,如果是正常的保存，就按两次大写的 “Z” 就保存退出了。 （八）wq 保存，然后把 sudoers 文件权限改回去，毕竟这是一个重要的文件1chmod -v u-w /etc/sudoers 命令行显示: “mode of ‘/etc/sudoers’ changed from 0640 (rw-r—–) to 0440 (r–r—–)” （九）测试新用户 admin 进行登陆，使用 su Jack 操作到此，新增 admin 并且授权 sudo 就完成了. 本文借鉴：https://blog.csdn.net/xudailong_blog/article/details/80518266]]></content>
  </entry>
  <entry>
    <title><![CDATA[win7系统80端口被系统占用问题]]></title>
    <url>%2Fwin7Of80isUsed%2F</url>
    <content type="text"><![CDATA[#win7 系统 80 端口被系统占用问题 当你配置完 nginx 的 nginx.conf 文件之后，发现报错误: “nginx: [emerg] bind() to 0.0.0.0:80 failed (98: Address already in use)”这个报错就是说，你的 80 端口已经被使用了 接下来我们就使用下面的命令来查查是被那个进程给占用了 12netstat -ano|findstr 80 发现被 Pid = 4 的进程占用了(一般查出来的占用进程的 Pid 不是 4 的情况下，直接 kill 掉就可以了) 直接上解决办法: Win7 的 80 端口默认是被 System 进程占用的。用如下方法可以解决 System 进程占用 80 端口的问题： 打开 RegEdit:开始-运行-输入 regedit-调出注册表找到 HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\HTTP找到一个 DWORD 值 Start，将其改为 0重启电脑，System 进程将不会占用 80 端口]]></content>
  </entry>
  <entry>
    <title><![CDATA[Node.js---Basics(lesson2)]]></title>
    <url>%2FNode-js-Basics(lesson2)%2F</url>
    <content type="text"><![CDATA[Node.js 基础篇(lesson2)本系列博客借鉴的是”网易云课堂————LOOK 何老师的免费进阶课程《Node.js 进阶教程第一步(基础篇)》,地址:https://study.163.com/course/introduction/1003228034.htm&quot; 安装配置并写 hello.js本文主要讲解的是 node.js 的安装，与 demo hello.js 的练习 安装 Node.js 官方下载地址: https://nodejs.org/en/ ,下载最新版的 node.js windows 安装版就可以了 Linux 的安装版详见 我的博客的内容：在 Centos 7.5 的腾讯云服务器上安装全局 Node.js 这里主要介绍在 windows 系统上安装 Node.js 直接把从官网上下载的 exe 文件，双击打开，一路 “下一步” 即可 由于 windows 系统的 CMD 我个人觉得用起来不是很舒服，因此我采用的是 git bash 来替代的 CMD 直接在百度搜索栏中键入 “Git for Windows”,默认搜索出来的第一个就是，或者官网地址： https://gitforwindows.org/ 首页中间部分有个 “Download” 按钮，直接点击就可以了 下载后也是一路的 “下一步” 即可。安装完成后，可以在任意的位置点击鼠标右键，弹出的菜单栏中有两个带 “bash” 的操作指令 “Git Bash Here” 和 “Git GUI Here”,选择 “Git Bash Here” 然后输入 1node -v ，显示版本号，就证明 node.js 安装成功windows 版本的 node.js 安装包，默认把 npm 同时安装上 再输入 1npm -v ,显示版本号，就证明 npm 安装成功。 hello.js先上完整的 demo 代码1234567891011121314var http = require('http');http.createServer(function (request, response) &#123; response.writeHead(200, &#123; "Content-Type": 'text/html; charset=utf-8' &#125;); if (request.url !== '/favicon.ico') &#123; //加入该条件是为了防止浏览器内部机制造成的2次访问 console.log('访问'); response.write('hello,world'); response.end('hello,世界');//不写的话则没有 http 协议尾，浏览器会一起处于加载的状态，但是写上后会产生两次访问 &#125;&#125;).listen(8000);console.log("Server is running at http://localhost:8000/ or http://127.0.0.1:8000/") 然后在该文件所在的文件夹内点击右键，选择 “Git Bash Here”,然后输入下面的命令后，输入下面的命令 1node hello.js 看到”Server is running at http://localhost:8000/ or http://127.0.0.1:8000/&quot;,表示启动成功。 现在来详细讲解下 Demo 中各部分的含义1var http = require('http'); 上面的语句的意思是，声明一个 var 变量 http 给其赋值为 node.js 中的 http 12345678910http.createServer(function (request, response) &#123; response.writeHead(200, &#123; "Content-Type": 'text/html; charset=utf-8' &#125;); if (request.url !== '/favicon.ico') &#123; //加入该条件是为了防止浏览器内部机制造成的2次访问 console.log('访问'); response.write('hello,world'); response.end('hello,世界');//不写的话则没有 http 协议尾，浏览器会一起处于加载的状态，但是写上后会产生两次访问 &#125;&#125;).listen(8000); “createServer” http 中有一个方法，是创建服务，他里面放一个函数，函数中有两个参数, “request”为请求时携带的参数 “response”为请求结果返回的参数 “response.writeHead”为，给 “response”写请求头，其内部包括: 1. 返回状态码:200; 2.内容类型为’text/html; charset=utf-8’]]></content>
  </entry>
  <entry>
    <title><![CDATA[Node.js---Basics(lesson1)]]></title>
    <url>%2FNode-js-Basics(lesson1)%2F</url>
    <content type="text"><![CDATA[Node.js 基础篇(lesson1)本系列博客借鉴的是”网易云课堂————LOOK 何老师的免费进阶课程《Node.js 进阶教程第一步(基础篇)》,地址:https://study.163.com/course/introduction/1003228034.htm&quot; 什么是 Node.js 编写高性能网络服务器的 Javascript 工具包(用 JS 开发服务端程序) 单线程、异步、事件驱动 特点：快、耗内存多 异步小号内存测试:网络上一个百万级并发测试,未优化的前提下, 1M 的连接量,消耗了 16G 的内存 Node.js vs PHP 优点: 性能高,(机制问题)开发效率高,(省不少优化的事)应用范围广(可以开发桌面系统, electrom 框架) 缺点 新、人少中间间少IDE 不完善 Node.js 的劣势和解决方案 默认不支持多核，但是用 cluster 可以解决 默认不支持服务器集群, node-http-proxy 可以解决 使用 Nginx 做负载均衡,静态的有 Nginx 处理,动态的由 node.js 处理 forever 或 node-cluster 实现灾难恢复 框架选择 比较热门的包括: express、koa、Hapi以及 express 基础之上的 sails express: 完善、稳定、文档全、社区大 koa: 超前,正在完善中 Hapi: 复杂(一个简单的 hello,world 都要做很多堆砌),适合复杂的大型项目 本教程学习路径 node.js 基础 Express 框架 sails 框架 项目 sails + vue.js sails + react 编辑器的选择个人目前在使用的是 VsCode，基于使用的时间较长比较顺手，推荐新手使用 sublime 熟悉下，然后可以用 webstorm 、VsCode 或者是 IDEA]]></content>
  </entry>
  <entry>
    <title><![CDATA[Nginx]]></title>
    <url>%2FNginx%2F</url>
    <content type="text"><![CDATA[如何离线安装 Nginx准备工作gcc 和 g++ 在 Linux 系统中必须有可以使用下面的命令来测试是否有 gcc 和 g++ 1yum install -y gcc gcc-c++ 也可以使用下面的命令 1gcc 提示你编译失败,就证明已经安装。 准备 Nginx 的安装包和 pcre zlib openssl 三个安装包我这里用的是 Nginx-1.3.1 pcre-8.31 zlib-1.2.3 openssl-1.0.1.c 安装 Nginx 依赖包1cd home/ 切换到 home 目录下 1mkdir Jack 创建一个名字为 Jack 的文件(特意说明下，Jack 就是你的非 root 的登录名),并且创建一个名为 nginx-server 的文件夹用来存放 nginx 12cd Jack/mkdir nginx-server 进入到 Jack 文件夹内，然后把安装包跟依赖包到考入到该目录下 之后我们逐步安装： 安装 pcre 1234567891011121314151617181920tar -zxvf pcre-8.31.tar.gzcd pcre-8.31./configuresu你的 root 登录密码makemake installsu Jack你的 Jack 用户登录密码cd ../ 安装 openssl 1234567891011121314151617181920tar -zxvf openssl-1.0.1.c.tar.gzcd openssl-1.0.1.c./configsu你的 root 登录密码makemake installsu Jack你的 Jack 用户登录密码cd ../ 安装 zlib 1234567891011121314151617181920tar -zxvf zlib-1.2.3.tar.gzcd zlib-1.2.3CFLAGS="-O3 -fPIC" ./configuresu你的 root 登录密码makemake installsu Jack你的 Jack 用户登录密码cd ../ 安装 nginx 1234567891011121314151617181920212223tar -zxvf nginx.1.3.1.tar.gzcd nginx-1.3.1./configure --prefix=/home/Jack/nginx-server --with-pcre=/home/Jack/pcre-8.31 --with-openssl=/home/Jack/openssl-1.0.1.c --with-zlib=/home/Jack/zlib-1.2.3su你的 root 登录密码makemake installsu Jack你的 Jack 用户登录密码cd ../cd nginx-serverls ls 之后你可以看到 conf html sbin 等 4 个文件 然后 12cd sbin/sudo ./nginx -v 显示出 nginx-1.3.1 ,就证明安装成功 Nginx 安装成功后，起项目报错问题以及解决办法 Nginx 启动报错: nginx :[alert] could not open error log file…..解决办法: 在非 root 登录下 使用 “sudo ./nginx”，之后输入 Jack 的登录密码即可 Nginx 启动报错: nginx: [emerg] the “ssl” paramter requires ngx_http_module in /home/Jack/nginx-server/conf/nginx.conf:102 解决办法: 进入到之前解压完的 nginx 的目录下，重新输入如下代码(执行前记得备份 /home/Jack1/nginx-server/conf/nginx-conf)，如果不需要请忽略()中的内容 12345678910./configure --prefix=/home/Jack/nginx-server --with-pcre=/home/Jack/pcre-8.31 --with-openssl=/home/Jack/openssl-1.0.1.c --with-zlib=/home/Jack/zlib-1.2.3 --with-http_stub_status_module --with-http_ssl_modulesu你的 root 登录密码makemake install nginx 启动报: “[emerg] bind() to 0.0.0.0:XXXX failed(13: Permission denied)” 解决方法: 1. 端口小于 1024 情况:报错举例: “[emerg] bind() to 0.0.0.0:80 failed(13: Permission denied)”原因是因为 1024 以下端口启动时需要 root 权限，所以切换到 root 下，在启动即可，但是这个不适合于我们这种在非 root 账号下启动 nginx 的需求。 端口大于 1024 情况:报错举例: “[emerg] bind() to 0.0.0.0:8300 failed(13: Permission denied)”这种情况，我们需要先查询下 http 允许访问的端口: 12firewall-cmd --zone=public --list-ports 没有我们需要的端口，因此需要我们手动添加，执行下面的命令 123456firewall-cmd --zone=public --add-port=8300/tcp --permanent //（--permanent永久生效，没有此参数重启后失效）firewall-cmd --reloadfirewall-cmd --zone= public --query-port=80/tcp 升级 Nginx 到 15.0 以上的版本后,会报 “nginx: [warn] the “ssl” directive is deprecated, use the “listen … ssl” directive instead in /usr/local/nginx/conf/nginx.conf” 问题分析这是一个 warn 警告,nginx 也能正常使用，但是由于强迫症，还是要把 warn 解决掉。 根据翻译，nginx 提示 ssl 这个指令已经不建议使用，要使用 listen … ssl 替代。网上查找 nginx 更新日志里面，也有提到： Change: the “ssl” directive is deprecated; the “ssl” parameter of the “listen” directive should be used instead.1ssl 不建议作为一个指令使用，而是应该 listen 指令的一个参数。 解决方法直接删除 ssl on 就行了。 nginx 如何隐藏版本信息号 解决方法: 在 nginx 安装的目录下，进入到 conf/ 目录里，打开 nginx.conf 文件，在 http:{}中加入下面的代码即可 12server_tokens off; nginx 启动报错:” forbidden 403 “ 解决方法：/conf/nginx.conf 中设置 user : 你运行的 ./nginx 的当前用户或者用 “ll” 命令查看，你装 nginx 的那个目录的所有者是不是你当前的用户。 7 nginx 启动正常， curl 地址 显示正常，就是浏览器无法访问解决办法：把对应的端口打开即可firewall-cmd –zone=public –add-port=你要添加的端口/tcp –permanent （–permanent 永久生效，没有此参数重启后失效）systemctl restart firewalld.service 即可。 附录：1.firewalld 的基本使用 启动： systemctl start firewalld查看状态： systemctl status firewalld停止： systemctl disable firewalld禁用： systemctl stop firewalld systemctl 是 CentOS7 的服务管理工具中主要的工具，它融合之前 service 和 chkconfig 的功能于一体。 启动一个服务：systemctl start firewalld.service关闭一个服务：systemctl stop firewalld.service重启一个服务：systemctl restart firewalld.service显示一个服务的状态：systemctl status firewalld.service在开机时启用一个服务：systemctl enable firewalld.service在开机时禁用一个服务：systemctl disable firewalld.service查看服务是否开机启动：systemctl is-enabled firewalld.service查看已启动的服务列表：systemctl list-unit-files|grep enabled查看启动失败的服务列表：systemctl –failed 配置 firewalld-cmd 查看版本： firewall-cmd –version查看帮助： firewall-cmd –help显示状态： firewall-cmd –state查看所有打开的端口： firewall-cmd –zone=public –list-ports更新防火墙规则： firewall-cmd –reload查看区域信息: firewall-cmd –get-active-zones查看指定接口所属区域： firewall-cmd –get-zone-of-interface=eth0拒绝所有包：firewall-cmd –panic-on取消拒绝状态： firewall-cmd –panic-off查看是否拒绝： firewall-cmd –query-panic 那怎么开启一个端口呢添加firewall-cmd –zone=public –add-port=80/tcp –permanent （–permanent 永久生效，没有此参数重启后失效）重新载入firewall-cmd –reload或者systemctl restart firewalld.service查看firewall-cmd –zone= public –query-port=80/tcp删除firewall-cmd –zone= public –remove-port=80/tcp –permanent nginx 启动 命令 ./nginxnginx 关闭命令 ./nginx -s stopnginx 查看端口是否启动命名 ps -aux | grep nginx 把当前文件夹的所有者修改为 owner 的方法 1chown owner * -R 把当前文件夹的所属组修改为 owner 的方法 1chgrp owner * -R]]></content>
  </entry>
  <entry>
    <title><![CDATA[nodejsonCentos]]></title>
    <url>%2FnodejsonCentos%2F</url>
    <content type="text"><![CDATA[在 Centos 7.5 的腾讯云服务器上安装全局 Node.js首先使用 1cd ~ 将当期目录切换到 ~ 目录下 12wget https://nodejs.org/dist/v10.16.0/node-v10.16.0-linux-x64.tar.xz 这个是在 node 官网上下载 node 包,将命令中的版本号换成对应的版本号就可以,我下载的版本是 V.10.16.0 然后在当前下载的 jar 包的文件夹下，使用如下命令，将 jar 包解压 1tar -xvf node-v10.16.0-linux-x64.tar.xz 先确认你 nodejs 的路径，我这里的路径为~/node-v9.3.0-linux-x64/bin。确认后依次执行 12ln -s ~/node-v9.3.0-linux-x64/bin/node /usr/bin/nodeln -s ~/node-v9.3.0-linux-x64/bin/npm /usr/bin/npm 注意 ln 指令用于创建关联（类似与 Windows 的快捷方式）必须给全路径，否则可能关联错误。 最后使用命令 12node -vnpm -v 显示出对应的版本号，就证明安装成功了]]></content>
  </entry>
  <entry>
    <title><![CDATA[elasticsearch]]></title>
    <url>%2Felasticsearch%2F</url>
    <content type="text"><![CDATA[elasticsearch 数据库要加入权限控制，使用的是 x-pack 插件，前端直接访问数据库的时候，只需要在 ajax 请求的加入 12345678910$.ajax(&#123; url: "ES数据库地址", type: "POST/GET", data: "传入的数据", contentType: "application/json", beforeSend: function(xhr) &#123; xhr.setRequestHeader("Authorization", `Basic $&#123;btoa("username:password")&#125;`); &#125;, success: function(result) &#123;&#125;&#125;); 会涉及到跨域的问题，要将 es 配置文件中涉及到跨域的地方打开，包括带请求头的部分 es 数据库修改密码这里测试的账户为: elastic 1234curl -u elastic -XPUT 'http://192.168.1.11:9200/_xpack/security/user/elastic/_password?pretty' -H 'Content-Type: application/json' -d'&#123; "password" : "new_password"&#125;' 其中 192.168.1.11为 es 数据库的地址 IP 参考地址： https://www.jianshu.com/p/2ecac3ae1b67 附录: 在 Linux 系统上打包命令: 12tar -cvf 想要起的包名字.tar 要打包的文件夹名/ 查看内存 12df -h 查看 ElasticSearch 数据库的服务是否在运行的指令 12]]></content>
  </entry>
  <entry>
    <title><![CDATA[regexpAll]]></title>
    <url>%2FregexpAll%2F</url>
    <content type="text"><![CDATA[前端常用的正则表达式大全1. 匹配用户名规则描述: · 长度 4-6 位： {4,16}· 字母： [a-z][a-z]· 数字： [0-9]· 下划线： [_]· 减号： [-]· 结尾加上 i 是不区分大小写· 结尾加上 g 是全部匹配· / / 内]]></content>
  </entry>
  <entry>
    <title><![CDATA[同心圆坐标算法]]></title>
    <url>%2FechartsGraph%2F</url>
    <content type="text"><![CDATA[前言由于项目中要搭建人物关系图谱，基于定制化不是很强，并且要求在短时间内实现同心圆人物关系图的效果，因此，我采用的是基于 Echarts V4 版本和 JQuery V3.4.0 来先实现的 graph 图,根据自己的摸索，研究出来了，echarts 的 graph 图坐标系的分布： 先来阐述下，Echarts 的 graph 图的坐标系的展示假设我们取的展示 echarts 的盒子的大小为 400pxX400pxecharts 中 graph 的坐标系是左上角为 (0,0)点，右下角为 (400,400)根据这个坐标位置的关系，我们可以确定要做同心圆的中心点的位置为 (200,200),话不多说，先来个干货,呈上一段动态生成的 nodes 和 links 的基本 demo 数据 nodes 的数据的 id 一定要是字符串的类型，不要是数字 否则会出现如图的效果点点击这里 12345678910111213141516171819202122var nodes = []; var links = []; for (var i = 0; i &lt; 6; i++) &#123; nodes.push(&#123; id: `$&#123;i&#125;`, //这个 ID 在 nodes 数据中必须唯一，在 links 中可以重复出现 name: `demo$&#123;i&#125;`, //每个节点显示的名字 symbolSize: 20, //节点在图中显示的大小 value: 20 //每个节点的数据大小，一般情况下保持和每个节点的 symbolSize 的值一致 &#125;); &#125; nodes.forEach((ele, index, arr) =&gt; &#123; if (index != arr.length - 1) &#123; links.push(&#123; id: `$&#123;index * 2&#125;`, //这个 ID 在 links 必须唯一，但是只是作为每条数据的 ID 而已，不影响图展示 name: `demo$&#123;index&#125;---demo$&#123;index * 1 + 1 * 1&#125;`, //节点和节点的连接线上显示的数据内容 source: `$&#123;index&#125;`, //起始点(来源) target: `$&#123;index * 1 + 1 * 1&#125;` &#125;); &#125; &#125;); 上面的代码是最基本的数据，但是要注意一点，如果你在 option 中 的 series 数组下的 layout 的属性值不写，或者其值为 none 的时候，会报错 Uncaught TypeError: Cannot read property ‘off’ of undefined echarts 中 option 的 series 的 layout 的默认属性值默认为 none这个问题的主要原因,就是在于 nodes 数据上,对于初次使用 echarts 的 graph 图的同学来说，上来就给 nodes 数据加入 x , y 坐标的值，难度系数比较大，因为不懂如何通过自己算出每个点的坐标来进行展示，所以就会报上面的问题，还有可能是你的 nodes 数据中的 某个点的 x 或者 y 出现 NAN 的情况,所以想熟悉下的童鞋，在没有给 nodes 数据传入 x , y 的时候，一定要设置为 “force” 或者 “circular”. 上个完整的前端代码，以供同学们学习：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8" /&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge" /&gt; &lt;title&gt;echarts 同心圆图&lt;/title&gt; &lt;/head&gt; &lt;script src="./echarts.js"&gt;&lt;/script&gt; &lt;script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"&gt;&lt;/script&gt; &lt;style&gt; body &#123; box-sizing: border-box; margin: 0; width: 100%; height: 100%; &#125; &lt;/style&gt; &lt;body&gt; &lt;div id="graph" style="width:vw;height:100vh;"&gt;&lt;/div&gt; &lt;script&gt; $(function() &#123; var nodes = []; var links = []; for (var i = 0; i &lt; 6; i++) &#123; nodes.push(&#123; id: `$&#123;i&#125;`, //这个 ID 在 nodes 数据中必须唯一，在 links 中可以重复出现 name: `demo$&#123;i&#125;`, //每个节点显示的名字 symbolSize: 20, //节点在图中显示的大小 value: 20 //每个节点的数据大小，一般情况下保持和每个节点的 symbolSize 的值一致 &#125;); &#125; nodes.forEach((ele, index, arr) =&gt; &#123; if (index != arr.length - 1) &#123; links.push(&#123; id: index * 2 + 3, //这个 ID 在 links 必须唯一，但是只是作为每条数据的 ID 而已，不影响图展示 name: `demo$&#123;index&#125;---demo$&#123;index * 1 + 1 * 1&#125;`, //节点和节点的连接线上显示的数据内容 source: `$&#123;index&#125;`, //起始点(来源) target: `$&#123;index * 1 + 1 * 1&#125;` &#125;); &#125; &#125;); getGraph(nodes, links); &#125;); function getGraph(nodes, links) &#123; var graph = &#123; nodes: nodes, links: links &#125;; myChart = echarts.init(document.getElementById("graph")); option = &#123; title: &#123; //标题 text: "同心圆关系图", //标题展示的内容 top: "10", //标题定位，距顶部的距离为10 left: "center" //距左边的值为 "center" (中间) &#125;, tooltip: &#123; //修改划上去的edge显示内容 formatter: function(param) &#123; if (param.dataType == "edge") &#123; return `$&#123;param.data.source&#125;&gt;$&#123;param.data.target&#125;`; &#125; return; &#125;, rich: &#123; color: "black" &#125; &#125;, animationDuration: 1500, //初始动画的时长，支持回调函数，可以通过每个数据返回不同的 delay 时间实现更戏剧的初始动画效果 animationEasingUpdate: "quinticInOut", //数据更新动画的缓动效果 series: [ &#123; type: "graph", //展示的类型为关系图 // layout: "force", layout: "circular", //图的布局。'none' 不采用任何布局，使用节点中提供的 x， y 作为节点的位置。'circular' 采用环形布局，'force' 采用力引导布局,[ default: 'none' ] roam: true, //是否开启鼠标缩放和平移漫游。默认不开启。如果只想要开启缩放或者平移，可以设置成 'scale' 或者 'move'。设置成 true 为都开启,[ default: false ] draggable: true, //节点是否可拖拽，只在使用力引导布局的时候有用,[ default: false ] focusNodeAdjacency: true, //是否在鼠标移到节点上的时候突出显示节点以及节点的边和邻接节点,[ default: false ] data: graph.nodes, //节点数据 links: graph.links, //连线数据 symbol: "circle", //关系图节点标记的图形。ECharts 提供的标记类型包括 'circle', 'rect', 'roundRect', 'triangle', 'diamond', 'pin', 'arrow', 'none',可以通过 'image://url' 设置为图片，其中 URL 为图片的链接，或者 dataURI,[ default: 'circle' ] edgeSymbol: ["circle", "arrow"], //边两端的标记类型，可以是一个数组分别指定两端，也可以是单个统一指定。默认不显示标记，常见的可以设置为箭头,[ default: ['none', 'none'] ] edgeSymbolSize: 10, //边两端的标记大小，可以是一个数组分别指定两端，也可以是单个统一指定。可以是数组[10,10],[ default: 10 ] cursor: "pointer", //鼠标悬浮时在图形元素上时鼠标的样式是什么。同 CSS 的 cursor,[ default: 'pointer' ] itemStyle: &#123; //图形样式 normal: &#123; color: "#06d55e", borderColor: "#fff", borderWidth: 1, shadowBlur: 10, shadowColor: "rgba(0,0,0,0.3)" &#125; &#125;, label: &#123; //图形上的文本标签，可用于说明图形的一些数据信息，比如值，名称等，label选项在 ECharts 2.x 中放置于itemStyle下，在 ECharts 3 中为了让整个配置项结构更扁平合理，label 被拿出来跟 itemStyle 平级，并且跟 itemStyle 一样拥有 emphasis 状态。 show: true, position: "inside", formatter: "&#123;b&#125;", fontSize: 20, rich: &#123; b: &#123; color: "#fff" &#125; &#125; &#125;, lineStyle: &#123; //关系边的公用线条样式。其中 lineStyle.color 支持设置为'source'或者'target'特殊值，此时边会自动取源节点或目标节点的颜色作为自己的颜色。 color: "source", curveness: 0.1 //边的曲度，支持从 0 到 1 的值，值越大曲度越大 &#125;, edgeLabel: &#123; //连线上显示的内容的设置 color: "black", position: "middle" //连线上的内容显示的位置 &#125;, emphasis: &#123; //hover展示的效果 lineStyle: &#123; width: 3 &#125;, label: &#123; show: false &#125; &#125; &#125; ] &#125;; myChart.setOption(option); window.onresize = function() &#123; //随着浏览器视窗的变化，自适应 myChart.resize(); &#125;; &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 展示的图片效果 加入同心圆算法上干货: 基础算法12345678910111213141516171819//同心圆关系图坐标点计算方法function getPoint(r, ox, oy, count) &#123; var point = []; //结果 /* * 求圆周上等分点的坐标 * ox,oy为圆心坐标 * r为半径 * count为等分个数 */ var radians = (Math.PI / 180) * Math.round(360 / count), //弧度 i = 0; for (; i &lt; count; i++) &#123; var x = ox + r * Math.sin(radians * i), y = oy + r * Math.cos(radians * i); point.unshift(&#123; x: x, y: y &#125;); //为保持数据顺时针 &#125; return point;&#125; 这个是基本的同心圆坐标的数学算法，下面我们把上面的代码进行改造下 处理后算法12345678910111213141516171819202122232425262728function getPoint(centerId, nodes) &#123; /* * 求圆周上等分点的坐标 * ox,oy为圆心坐标 * r为半径 */ var ox = window.innerWidth / 2; var oy = window.innerHeight / 2; var r = ox &gt; oy ? oy - 100 : ox - 100; var newNodes = []; var radians = (Math.PI / 180) * Math.round(360 / (nodes.length - 1)), //弧度 i = 0; for (; i &lt; nodes.length; i++) &#123; if (nodes[i].id == centerId) &#123; newNodes.unshift(nodes[i]); &#125; else &#123; newNodes.push(nodes[i]); &#125; &#125; for (var j = 0; j &lt; newNodes.length; j++) &#123; newNodes[j].x = ox + r * Math.sin(radians * j); newNodes[j].y = oy + r * Math.cos(radians * j); &#125; //中心点位更新 newNodes[0].x = ox; newNodes[0].y = oy; return newNodes || null; &#125; 直接上最终代码:记得把 layout 的值修改为 “none” 或者直接注释/删除掉 layout 属性 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8" /&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge" /&gt; &lt;title&gt;echarts 同心圆图&lt;/title&gt; &lt;/head&gt; &lt;script src="./echarts.js"&gt;&lt;/script&gt; &lt;script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"&gt;&lt;/script&gt; &lt;style&gt; body &#123; box-sizing: border-box; margin: 0; width: 100%; height: 100%; &#125; &lt;/style&gt; &lt;body&gt; &lt;div id="graph" style="width:vw;height:100vh;"&gt;&lt;/div&gt; &lt;script&gt; $(function() &#123; var nodes = []; var links = []; for (var i = 0; i &lt; 6; i++) &#123; nodes.push(&#123; id: `$&#123;i&#125;`, //这个 ID 在 nodes 数据中必须唯一，在 links 中可以重复出现 name: `demo$&#123;i&#125;`, //每个节点显示的名字 symbolSize: 20, //节点在图中显示的大小 value: 20 //每个节点的数据大小，一般情况下保持和每个节点的 symbolSize 的值一致 // x: 662.0767566415067*i, // y: 71.20162612375115 &#125;); &#125; nodes.forEach((ele, index, arr) =&gt; &#123; if (index != arr.length - 1) &#123; links.push(&#123; id: index * 2 + 3, //这个 ID 在 links 必须唯一，但是只是作为每条数据的 ID 而已，不影响图展示 name: `demo$&#123;index&#125;---demo$&#123;index * 1 + 1 * 1&#125;`, //节点和节点的连接线上显示的数据内容 source: `$&#123;index&#125;`, //起始点(来源) target: `$&#123;index * 1 + 1 * 1&#125;` &#125;); &#125; &#125;); nodes = getPoint("1", nodes); if (nodes) &#123; getGraph(nodes, links); &#125; &#125;); function getGraph(nodes, links) &#123; var graph = &#123; nodes: nodes, links: links &#125;; myChart = echarts.init(document.getElementById("graph")); option = &#123; title: &#123; //标题 text: "同心圆关系图", //标题展示的内容 top: "10", //标题定位，距顶部的距离为10 left: "center" //距左边的值为 "center" (中间) &#125;, tooltip: &#123; //修改划上去的edge显示内容 formatter: function(param) &#123; if (param.dataType == "edge") &#123; return `$&#123;param.data.source&#125;&gt;$&#123;param.data.target&#125;`; &#125; return; &#125;, rich: &#123; color: "black" &#125; &#125;, animationDuration: 1500, //初始动画的时长，支持回调函数，可以通过每个数据返回不同的 delay 时间实现更戏剧的初始动画效果 animationEasingUpdate: "quinticInOut", //数据更新动画的缓动效果 series: [ &#123; type: "graph", //展示的类型为关系图 // layout: "force", layout: "none", //图的布局。'none' 不采用任何布局，使用节点中提供的 x， y 作为节点的位置。'circular' 采用环形布局，'force' 采用力引导布局,[ default: 'none' ] roam: true, //是否开启鼠标缩放和平移漫游。默认不开启。如果只想要开启缩放或者平移，可以设置成 'scale' 或者 'move'。设置成 true 为都开启,[ default: false ] draggable: true, //节点是否可拖拽，只在使用力引导布局的时候有用,[ default: false ] focusNodeAdjacency: true, //是否在鼠标移到节点上的时候突出显示节点以及节点的边和邻接节点,[ default: false ] data: graph.nodes, //节点数据 links: graph.links, //连线数据 symbol: "circle", //关系图节点标记的图形。ECharts 提供的标记类型包括 'circle', 'rect', 'roundRect', 'triangle', 'diamond', 'pin', 'arrow', 'none',可以通过 'image://url' 设置为图片，其中 URL 为图片的链接，或者 dataURI,[ default: 'circle' ] edgeSymbol: ["circle", "arrow"], //边两端的标记类型，可以是一个数组分别指定两端，也可以是单个统一指定。默认不显示标记，常见的可以设置为箭头,[ default: ['none', 'none'] ] edgeSymbolSize: 10, //边两端的标记大小，可以是一个数组分别指定两端，也可以是单个统一指定。可以是数组[10,10],[ default: 10 ] cursor: "pointer", //鼠标悬浮时在图形元素上时鼠标的样式是什么。同 CSS 的 cursor,[ default: 'pointer' ] itemStyle: &#123; //图形样式 normal: &#123; color: "#06d55e", borderColor: "#fff", borderWidth: 1, shadowBlur: 10, shadowColor: "rgba(0,0,0,0.3)" &#125; &#125;, label: &#123; //图形上的文本标签，可用于说明图形的一些数据信息，比如值，名称等，label选项在 ECharts 2.x 中放置于itemStyle下，在 ECharts 3 中为了让整个配置项结构更扁平合理，label 被拿出来跟 itemStyle 平级，并且跟 itemStyle 一样拥有 emphasis 状态。 show: true, position: "inside", formatter: "&#123;b&#125;", fontSize: 20, rich: &#123; b: &#123; color: "#fff" &#125; &#125; &#125;, lineStyle: &#123; //关系边的公用线条样式。其中 lineStyle.color 支持设置为'source'或者'target'特殊值，此时边会自动取源节点或目标节点的颜色作为自己的颜色。 color: "source", curveness: 0.1 //边的曲度，支持从 0 到 1 的值，值越大曲度越大 &#125;, edgeLabel: &#123; //连线上显示的内容的设置 color: "black", position: "middle" //连线上的内容显示的位置 &#125;, emphasis: &#123; //hover展示的效果 lineStyle: &#123; width: 3 &#125;, label: &#123; show: false &#125; &#125; &#125; ] &#125;; myChart.setOption(option); window.onresize = function() &#123; //随着浏览器视窗的变化，自适应 myChart.resize(); &#125;; &#125; function getPoint(centerId, nodes) &#123; /* * 求圆周上等分点的坐标 * ox,oy为圆心坐标 * r为半径 *centerId为想要作为中心点的节点的ID *nodes为要传入到echarts中的节点数据 */ var ox = window.innerWidth / 2; var oy = window.innerHeight / 2; var r = ox &gt; oy ? oy - 100 : ox - 100; //整个同心圆的大小半径 var newNodes = []; //计算完的结果 var radians = (Math.PI / 180) * Math.round(360 / (nodes.length - 1)), //弧度 i = 0; for (; i &lt; nodes.length; i++) &#123; //这个for循环是让要放在中心点的那个点，放在数组的第一位，为后面的将中心点的坐标赋值给它提供便利 if (nodes[i].id == centerId) &#123; newNodes.unshift(nodes[i]); //中心点坐标放到第一位的方法 &#125; else &#123; newNodes.push(nodes[i]); //正常的 push &#125; &#125; for (var j = 1; j &lt; newNodes.length; j++) &#123; //这里是将数据除了索引为0的数组元素添加计算好的 x y 坐标 newNodes[j].x = ox + r * Math.sin(radians * j); newNodes[j].y = oy + r * Math.cos(radians * j); &#125; //中心节点的坐标 newNodes[0].x = ox; newNodes[0].y = oy; return newNodes || null; &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 最后的效果图为: 造数据的时候，nodes 的 id 不为 String 类型并且数据中 id 和 name 的值没有相同的时候会报如下错误 ===&gt; 如图 简单的解释下这个报错的意思——是指你的 nodes 数据中 id 或 name 有相同。 有需要详细解释的欢迎发邮件给我 601709253@qq.com]]></content>
  </entry>
  <entry>
    <title><![CDATA[iframe]]></title>
    <url>%2Fiframe%2F</url>
    <content type="text"><![CDATA[简单阐述下 Html 标签 iframeMDN 上的定义HTML 内联框架元素 iframe 表示嵌套的浏览上下文，有效地将另一个 HTML 页面嵌入到当前页面中。 我的理解iframe 就是在 Html 页面内再嵌套一个页面，可以做成浮窗的效果。 iframe 常用属性: frameborder :是否显示边框，1(yes),0(no) height :框架作为一个普通元素的高度，建议在使用 css 设置。 width :框架作为一个普通元素的宽度，建议使用 css 设置。 name :框架的名称，window.frames[name]时专用的属性。 scrolling :框架的是否滚动。yes,no,auto。 src ：内框架的地址，可以使页面地址，也可以是图片的地址。 srcdoc ： 用来替代原来 HTML body 里面的内容。但是 IE 不支持, 不过也没什么卵用 sandbox : 对 iframe 进行一些列限制，IE10+支持 iframe 使用条件我们通常使用 iframe 最基本的特性，就是能自由操作 iframe 和父框架的内容(DOM). 但前提条件是同域. 如果跨域顶多只能实现页面跳转 window.location.href. 怎么来判断是否跨域了呢？最直观简单的方式，就是比较 iframe 标签中的 src 属性的值和 iframe 所在页面的地址栏中的地址域名是否相同（主要看首部是否一样） for example： 1234567891011121314A:&lt;iframe id="mainIframe" name="mainIframe" src="/main.html" frameborder="0" scrolling="auto"&gt;&lt;/iframe&gt;B:&lt;iframe id="mainIframe" name="mainIframe" src="http://www.baidu.com" frameborder="0" scrolling="auto"&gt;&lt;/iframe&gt; 使用 A 时，因为同域，父页面可以对子页面进行改写,反之亦然。使用 B 时，不同域，父页面没有权限改动子页面,但可以实现页面的跳转 直接上干货代码，可以自己复制后，在自己的电脑本地测试index.html 文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt; &lt;title&gt;main&lt;/title&gt; &lt;style type="text/css"&gt; body &#123; box-sizing: border-box; margin: 0; background-color: #203048; &#125; .title &#123; position: absolute; top: 10px; left: 10px; font-weight: bold; font-size: 2em; color: #fff; &#125; .function_btn &#123; width: 100%; height: 30px; margin: 10px 0; display: flex; justify-content: center; align-items: center; &#125; .function_btn &gt; a &#123; margin-right: 20px; text-decoration: none; color: #fff; opacity: 0.7; &#125; iframe &#123; float: left; width: 48%; height: 500px; margin-left: 1%; /* border: 1px solid #eee; */ /* background: #ddd; */ display: table-cell; &#125; footer &#123; position: fixed; bottom: 20px; width: 100%; text-align: center; color: #fff; opacity: 0.7; &#125; &lt;/style&gt; &lt;script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; var gg = "这是main.html变量"; function ggMM() &#123; console.log(gg); &#125; function callIframeMethod() &#123; // js document.getElementById("frame").contentWindow.test(); // jq $("#frame")[0].contentWindow.test(); //用jquery调用需要加一个[0] $("#frame")[0] .contents() .text(); &#125; function callIframeField() &#123; // 以下两种方法可以达到同样的效果 console.log($("#frame")[0].contentWindow.ff); console.log(frame.window.ff); &#125; function callIframeHtml() &#123; // 以下两种方法可以达到同样的效果 console.log( $("#frame")[0] .contentWindow.$("#dd") .val() ); console.log(frame.window.$("#dd").val()); var t = document .getElementById("frame") .contentWindow.document.getElementById("dd"); console.log(t); // var t = document.getElementById('frame').contentWindow.document.getElementById('dd'); //console.log($("#frame")[0].contentWindow.document.getElementById("dd").value); //console.log($("#frame")[0].contentWindow.document.getElementById("dd").value); &#125; function giveParameter() &#123; $("#frame")[0].contentWindow.hellobaby = "dsafdsafsdafsdafsdafsdafsadfsadfsdafsadfdsaffdsaaaaaaaaaaaaa"; &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;span class="title"&gt;Index页面&lt;/span&gt; &lt;div class="function_btn"&gt; &lt;a href="javascript:void(0);" onclick="giveParameter(); return false;" &gt;参数传递&lt;/a &gt; &lt;a href="javascript:void(0);" onclick="callIframeMethod(); return false;" &gt;调用子iframe方法&lt;/a &gt; &lt;a href="javascript:void(0);" onclick="callIframeField(); return false;" &gt;调用子iframe变量&lt;/a &gt; &lt;a href="javascript:void(0);" onclick="callIframeHtml(); return false;" &gt;调用子iframe组件&lt;/a &gt; &lt;/div&gt; &lt;iframe id="frame" name="frame" src="frame.html" frameborder="0"&gt;&lt;/iframe&gt; &lt;iframe id="newFrame" name="newFrame" src="newFrame.html" frameborder="0" &gt;&lt;/iframe&gt; &lt;footer&gt;有问题请发邮箱: 18833527317@139.com&lt;/footer&gt; &lt;/body&gt;&lt;/html&gt; frame.html123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt; &lt;title&gt;frame&lt;/title&gt; &lt;style type="text/css"&gt; body &#123; background-color: #405678; &#125; a &#123; display: block; line-height: 30px; text-decoration: none; color: #fff; &#125; #dd &#123; width: 200px; height: 40px; line-height: 40px; border-radius: 3px; border-style: none; &#125; h1 &#123; color: #fff; opacity: 0.7; &#125; &lt;/style&gt; &lt;script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; var ff = "adfdasfdsafdsafdsaf"; function test() &#123; console.log($("#dd").val()); &#125; function callMainField() &#123; console.log(parent.gg); &#125; function callMainMethod() &#123; parent.ggMM(); &#125; function callMainHtml() &#123; console.log(parent.$("#frame").attr("id")); &#125; function getParameter() &#123; console.log(window.hellobaby); &#125; function ss() &#123; console.log("这是frame方法"); console.log(ff); &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;frame&lt;/h1&gt; &lt;a href="javascript:void(0);" onclick="getParameter(); return false;" &gt;接受参数&lt;/a &gt; &lt;a href="javascript:void(0);" onclick="callMainMethod(); return false;" &gt;调用父级方法，并且打印父级变量&lt;/a &gt; &lt;a href="javascript:void(0);" onclick="callMainField(); return false;" &gt;调用主窗口变量&lt;/a &gt; &lt;a href="javascript:void(0);" onclick="callMainHtml(); return false;" &gt;调用子iframe组件&lt;/a &gt; &lt;input id="dd" type="text" value="frame页面的input的value值" /&gt; &lt;/body&gt;&lt;/html&gt; newFrame 页面1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt; &lt;title&gt;在frame里嵌套frame&lt;/title&gt; &lt;style type="text/css"&gt; body &#123; background-color: #405678; &#125; h1 &#123; color: #fff; opacity: 0.7; &#125; input, a &#123; display: block; line-height: 30px; text-decoration: none; &#125; a &#123; color: #fff; &#125; iframe &#123; float: left; width: 48%; height: 250px; margin-top: 40px; background: #abc; border: 1px solid blue; &#125; #newFrame2 &#123; float: right; &#125; #nn &#123; width: 200px; height: 40px; line-height: 40px; border-radius: 3px; border-style: none; &#125; &lt;/style&gt; &lt;script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; var newFrame = &#123; name: "这是newFrame的变量值" &#125;; function callLevelFrame() &#123; var ff = parent.$("#frame")[0].contentWindow.ff; parent.$("#frame")[0].contentWindow.ss(); console.log('parent.$("#frame")[0].contentWindow.ff: ' + ff); &#125; function callLevelFrame1() &#123; console.log($("#newFrame1")[0].contentWindow.iframe1); $("#newFrame1")[0].contentDocument.querySelector( "input" ).style.background = "red"; $("#newFrame1")[0].contentDocument.querySelector("input").style.color = "white"; &#125; function frameFn() &#123; console.log("这是frame里面的方法franmeFn"); &#125; $(function() &#123; // setTimeout(function()&#123; // // console.log(parent.$("#frame")) // // console.log(parent.$("#frame")[0].contentWindow.ss()) // // console.log(parent.document.getElementById('frame').contentWindow.ss()); // &#125;,500) &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;newFrame&lt;/h1&gt; &lt;a href="#" onClick="callLevelFrame();"&gt;调用兄弟iframe&lt;/a&gt; &lt;a href="#" onClick="callLevelFrame1();" &gt;调用自己的子页面iframe1变量并且改变背景色为红色&lt;/a &gt; &lt;input id="nn" type="text" value="newFrame页面的input的value值" /&gt; &lt;iframe id="newFrame1" name="newFrame1" src="newFrame1.html" frameborder="0" &gt;&lt;/iframe&gt; &lt;iframe id="newFrame2" name="newFrame2" src="newFrame2.html" frameborder="0" &gt;&lt;/iframe&gt; &lt;/body&gt;&lt;/html&gt; newFrame11234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt; &lt;title&gt;newFrame1&lt;/title&gt; &lt;style type="text/css"&gt; body &#123; background-color: rbg(66, 182, 246); display: flex; flex-direction: column; justify-content: space-around; &#125; a &#123; display: block; line-height: 30px; color: #ee0000; text-decoration: none; &#125; #nn &#123; width: 200px; height: 40px; line-height: 40px; border-radius: 3px; border-style: none; &#125; &lt;/style&gt; &lt;script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; var iframe1 = "我是iframe1的变量"; function callnewFramFn() &#123; // js parent.parent.document .getElementById("newFrame") .contentWindow.frameFn(); // jq parent.parent.$("#newFrame")[0].contentWindow.frameFn(); &#125; function callnewFramParam() &#123; console.log( parent.parent.document.getElementById("newFrame").contentWindow .newFrame ); &#125; // $(function()&#123; // setTimeout(function()&#123; // // console.log(parent.parent.$("#newFrame")[0]) // // console.log(parent.$("#newFrame")[0].contentWindow.ss()) // // console.log(parent.document.getElementById('newFrame').contentWindow.ss()); // &#125;,500) // &#125;) function frame1() &#123; console.log(iframe1); parent .$("#newFrame2")[0] .contentWindow.$("#nn2") .val(iframe1); &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;newFrame1&lt;/h1&gt; &lt;div class="function_btn"&gt; &lt;a href="#" onClick="callnewFramFn();"&gt;调用newFram方法&lt;/a&gt; &lt;a href="#" onClick="callnewFramParam();"&gt;调用newFram变量&lt;/a&gt; &lt;/div&gt; &lt;input id="nn" type="text" value="这是newFrame1的input值" /&gt; &lt;/body&gt;&lt;/html&gt; newFrame2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt; &lt;title&gt;newFrame1&lt;/title&gt; &lt;style type="text/css"&gt; body &#123; background-color: rbg(66, 182, 246); display: flex; flex-direction: column; justify-content: space-around; &#125; a &#123; display: block; line-height: 30px; color: #ee0000; text-decoration: none; &#125; #nn2 &#123; width: 200px; height: 40px; line-height: 40px; border-radius: 3px; border-style: none; &#125; .function_btn &#123; width: 203px; height: 60px; &#125; &lt;/style&gt; &lt;script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; var iframe1 = "我是iframe2的变量"; function callnewFramFn1() &#123; parent.$("#newFrame1")[0].contentWindow.frame1(); console.log(parent.$("#newFrame1")); &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;newFrame2&lt;/h1&gt; &lt;div class="function_btn"&gt; &lt;a href="#" onClick="callnewFramFn1();"&gt;调用newFram1方法&lt;/a&gt; &lt;/div&gt; &lt;input id="nn2" type="text" value="这是newFrame1的input值" /&gt; &lt;/body&gt;&lt;/html&gt; 打开后的页面效果截图 附件下载地址:(http://lc-zltjehai.cn-n1.lcfile.com/545ea1f9e6c5a8680d49/iframe.rar)]]></content>
  </entry>
  <entry>
    <title><![CDATA[Markdown简易语法]]></title>
    <url>%2FMarkdown%2F</url>
    <content type="text"><![CDATA[1.什么是 MarkdownMarkdown 是一种纯文本格式的标记语言。通过简单的标记语法，它可以使普通文本内容具有一定的格式。深入学习请移步 Markdown 官网 2.Markdown 语法的优缺点优点： 1、因为是纯文本，所以只要支持 Markdown 的地方都能获得一样的编辑效果，可以让作者摆脱排版的困扰，专心写作。2、操作简单。比如:WYSIWYG 编辑时标记个标题，先选中内容，再点击导航栏的标题按钮，选择几级标题。要三个步骤。而 Markdown 只需要在标题内容前加#即可 缺点： 1、需要记一些语法（当然，是很简单。五分钟学会）。2、有些平台不支持 Markdown 编辑模式。 3.Markdown 简易指令，轻松上手标题写法超链接名 # 这是一级标题 ## 这是二级标题 ### 这是三级标题 #### 这是四级标题 ##### 这是五级标题 ###### 这是六级标题]]></content>
      <tags>
        <tag>针对于刚入门使用不熟悉的，语法文档</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo入门学习]]></title>
    <url>%2FHexostudy%2F</url>
    <content type="text"><![CDATA[什么是 HexoHexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 Hexo 搭建步骤 安装 Git bash (非必须,主要针对于 windows 中不习惯使用 cmd ,编译器是 VsCode 也可以不用这个) 安装 Node.js 安装 Hexo Github 上创建个人仓库 生成 SSH 添加到 GitHub 将 hexo 部署到 GitHub 将 yourname.github.io 绑定到个人域名 发布文章 1. 安装 GitGit 是目前世界上最先进的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。也就是用来管理你的 hexo 博客文章，上传到 GitHub 的工具。Git 非常强大，我觉得建议每个人都去了解一下。廖雪峰老师的 Git 教程写的非常好，大家可以了解一下。Git 教程 windows：到 git 官网上下载,Download git,下载后会有一个 Git Bash 的命令行工具，以后就用这个工具来使用 git。 linux：对 linux 来说实在是太简单了，因为最早的 git 就是在 linux 上编写的，只需要一行代码 1$ sudo apt-get install git 安装好后，用 git –version 来查看一下版本 2.安装 node.jsHexo 是基于 nodeJS 编写的，所以需要安装一下 nodeJs 和里面的 npm 工具。 windows：nodejs 选择 LTS 版本就行了。 linux： 12sudo apt-get install nodejssudo apt-get install npm 安装完后，打开命令行 12345node -vnpm -vsudo apt-get install nodejssudo apt-get install npm 检查一下有没有安装成功 顺便说一下，windows 在 git 安装完后，就可以直接使用 git bash 来敲命令行了，不用自带的 cmd，cmd 有点难用。 3.安装 Hexo前面 git 和 nodejs 安装好后，就可以安装 hexo 了，你可以先创建一个文件夹 blog，然后 cd 到这个文件夹下（或者在这个文件夹下直接右键 git bash 打开）。 输入命令 12npm install -g hexo-cli 安装完成之后,有两种方法生成 Hexo demo 1.自定义创建好一个文件夹，然后在该文件夹下的根目录中打开 Git bash ,或者你使用的编译器是 VS Code 可以直接将该文件夹托人到 VS Code 编辑器中，然后使用命令 Ctrl + ~ 打开终端窗口,输入 1hexo init (简写 hexo i) 只需等待 demo 自己加载完即可 2.相对于方法一来说比较简便,使用 一行代码直接在你当前目录下生成 Hexo Demo 1hexo init myBlog 其中 myBlog 是你 Hexo demo 的文件夹的名字。 新建完成后，指定文件夹目录下有： node_modules: 依赖包public：存放生成的页面scaffolds：生成文章的一些模板source：用来存放你的文章themes：主题 _config.yml: 博客的配置文件 再使用命令 1hexo g (这个是简写,原本的代码为 hexo generate) 然后再使用 1hexo s (这个是简写,原本的代码为 hexo server / hexo serve ),默认的端口是 4000,你也可以写成 hexo s -p 8080 ,自己定义本地起 hexo 服务的端口号 这样你就可以看到在 hexo 本地跑起来的服务了,特别说明下,在本地展示的效果方便于开发，可以实时的看到你所修改的博客界面。 4.如何将 github 和 hexo 联系起来?1. 你需要先配置一下 SSH key为什么要配置这个呢？因为你提交代码肯定要拥有你的 github 权限才可以，但是直接使用用户名和密码太不安全了，所以我们使用 ssh key 来解决本地和服务器的连接问题。 a. 重新打开 Git 命令窗口，输入下面命令: 1ssh-keygen -t rsa -C "git@github.com" //Github 的注册邮箱地址 b. 一路 Enter 过来就好，得到的信息如下: 1Your public key has been saved in /c/Users/user/.ssh/id_rsa.pub. 找到该文件并打开，复制里面的所有内容，然后进入 Sign in to GitHub：https://github.com/settings/ssh c. 依次执行下面步骤:点击 New SSH key —— Title：blog —— Key：输入刚才复制的 —— Add SSH key d. 测试一下是否成功,输入下方命令: 1ssh -T git@github.com //git@github.com 只要看到返回的信息中带有如下内容就说明成功了, 1Hi SquabbyZ! You've successfully authenticated 2.设置 Git 的 user name 和 email最好是在你当前 Hexo Demo 的目录下 依次执行下面的两个指令 12git config --global user.name "SquabbyZ" // 你的 github 用户名，非昵称git config --global user.email "git@github.com" // 填写你的 github 注册邮箱 3.修改参数及配置 deploy-git a.修改参数下面来简单介绍下 Hexo 项目中的配置文件 _config.ymlHexo 中的一些基本配置都需要在该文件里完成,这里只介绍简单的一些配置项 ① title: SquabbyZ 的小黑屋 //你自己博客的名字② subtitle: 技术博客 //博客副标题③ description: 一只致力于成为全栈的小胖纸 //你博客的描述④ author: Squabby Zhu //博客的作者 然后把配置文件下拉到最低下后,还有一些配置项需要去修改 ⑤ theme: next //主题文件夹的名字,关于更换主题内容可以直接点击更换主题⑥ deploy: //这里的配置,就是跟 Github 上你要把这个 demo 存入到仓库的配置type: git //类型 githubrepo: ssh://git@github.com/SquabbyZ/SquabbyZ.github.io.git//仓库地址，必须这样写 ssh://git@github.com/yourname/yourname.github.io.git ,注意这里的地址不是昵称。branch: master //仓库分支为:主分支上面这些配置好后,可以在 hexo 本地服务中看到除了 deploy 中修改外的其他修改的内容。 b.使用 deploy-git 工具,将本地做好的博客上传到 github 仓库中，更新仓库展示内容 先下载插件 deploy-git，指令如下: 1npm install hexo-deployer-git --save 插件下载完成后,按顺序输入如下命令: ① hexo clean //清除了你之前生成的东西，也可以不加② hexo generate //顾名思义，生成静态文章，可以用 hexo g 缩写③ hexo deploy //部署文章，可以用 hexo d 缩写]]></content>
      <tags>
        <tag>主要介绍 Hexo个人博客模板的搭建与Github的连通，以及个人域名绑定</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HelloWorld]]></title>
    <url>%2Fhelloworld%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
